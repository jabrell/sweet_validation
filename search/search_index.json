{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"api/","title":"Api Reference","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract class for class holding a value object that are always validated if changed.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>T</code> <p>An objects that contains values that are validated. Values are immutable and can only be replaced by reassigning the values attribute which triggers the validation process.</p> <p>Methods:</p> Name Description <code>validate</code> <p>Validate items</p> <code>is_valid</code> <p>Check if items are valid. It allows also allows for testing an item object against the validation used in the class.</p> Source code in <code>sweet_validation/items/validated_values.py</code> <pre><code>class ValidatedValues(ABC, Generic[T]):\n    \"\"\"Abstract class for class holding a value object that are always validated\n    if changed.\n\n    Attributes:\n        values: An objects that contains values that are validated.\n            Values are immutable and can only be replaced by reassigning the values\n            attribute which triggers the validation process.\n\n    Methods:\n        validate: Validate items\n        is_valid: Check if items are valid. It allows also allows for testing\n            an item object against the validation used in the class.\n    \"\"\"\n\n    _values: T\n\n    def __init__(self, values: T):\n        if self.is_valid(values=values, raise_exception=True):\n            self._values = values\n\n    @property\n    def values(self) -&gt; T:\n        \"\"\"Return the items of the column.\"\"\"\n        return deepcopy(self._values)\n\n    @values.setter\n    def values(self, values: T) -&gt; None:\n        \"\"\"Set the items of the column.\"\"\"\n        self.is_valid(values=values, raise_exception=True)\n        self._values = values\n\n    @abstractmethod\n    def is_valid(self, values: T, raise_exception: bool = True) -&gt; bool:\n        \"\"\"Check if values are not valid\n\n        Args:\n            values (T): A values object.\n            raise_exception (bool): If True, raise an error if the values\n                are not valid. If False returns False if validation fails.\n\n        Raises:\n            ValidationError: If the values are not valid. The validation error\n                should contain a report of the validation.\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @abstractmethod\n    def validate(self, values: T) -&gt; Any:\n        \"\"\"Validate values.\n\n        Args:\n            values (Any): Value object\n\n        Returns:\n            Any: Should return a validation report.\n        \"\"\"\n        raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#sweet_validation.items.ValidatedValues._values","title":"<code>_values</code>  <code>instance-attribute</code>","text":""},{"location":"api/#sweet_validation.items.ValidatedValues.values","title":"<code>values</code>  <code>property</code> <code>writable</code>","text":"<p>Return the items of the column.</p>"},{"location":"api/#sweet_validation.items.ValidatedValues.__init__","title":"<code>__init__(values)</code>","text":"Source code in <code>sweet_validation/items/validated_values.py</code> <pre><code>def __init__(self, values: T):\n    if self.is_valid(values=values, raise_exception=True):\n        self._values = values\n</code></pre>"},{"location":"api/#sweet_validation.items.ValidatedValues.is_valid","title":"<code>is_valid(values, raise_exception=True)</code>  <code>abstractmethod</code>","text":"<p>Check if values are not valid</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>T</code> <p>A values object.</p> required <code>raise_exception</code> <code>bool</code> <p>If True, raise an error if the values are not valid. If False returns False if validation fails.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the values are not valid. The validation error should contain a report of the validation.</p> Source code in <code>sweet_validation/items/validated_values.py</code> <pre><code>@abstractmethod\ndef is_valid(self, values: T, raise_exception: bool = True) -&gt; bool:\n    \"\"\"Check if values are not valid\n\n    Args:\n        values (T): A values object.\n        raise_exception (bool): If True, raise an error if the values\n            are not valid. If False returns False if validation fails.\n\n    Raises:\n        ValidationError: If the values are not valid. The validation error\n            should contain a report of the validation.\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#sweet_validation.items.ValidatedValues.validate","title":"<code>validate(values)</code>  <code>abstractmethod</code>","text":"<p>Validate values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Any</code> <p>Value object</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Should return a validation report.</p> Source code in <code>sweet_validation/items/validated_values.py</code> <pre><code>@abstractmethod\ndef validate(self, values: T) -&gt; Any:\n    \"\"\"Validate values.\n\n    Args:\n        values (Any): Value object\n\n    Returns:\n        Any: Should return a validation report.\n    \"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#columns","title":"Columns","text":"<p>               Bases: <code>ValidatedValues[list[Any]]</code></p> <p>A column is defined as a list of items and a frictionless Field object.</p> <p>The field object defines the type and constraints of the column and is based on the frictionless.Field object. Values are validated against this field every time they are appended or extended.</p> <p>For more information on the Field object, see: - Field types     under \"Data Fields\" - Constraints - Table and Field Scheme standard</p> <p>Attributes:</p> Name Type Description <code>field</code> <code>Field</code> <p>A frictionless Field object. The field object defines the type and constraints of the column. It can only be modified during instantiation. Otherwise it is immutable.</p> <code>values</code> <code>list</code> <p>A list of items. The items are validated against the field object. values are immutable and can only be set during instantiation or by replacing the values (e.g., col.values = [1, 2, 3]) which triggers a validation check.</p> <p>Methods:</p> Name Description <code>is_valid</code> <p>Raise a ValidationError if values are not valid. It can also be used to validate a list of items against the Field object.</p> <code>validate</code> <p>Validate values against the Field object.</p> <code>get_resource</code> <p>Return a frictionless Resource object with the values and meta-data.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the items are not valid given the Field object.</p> <code>AttributeError</code> <p>If the fields are modified after instantiation.</p> <p>Examples:</p> <pre><code>```python\nfrom frictionless.fields import IntegerField\nfield = IntegerField(name=\"test\", constraints={\"minimum\": 1, \"maximum\": 3})\ncol = Column(field=field, values=[1, 2, 3])\n```\n\nThe field property is immutable and values can only be replaced by a new list\nbut are otherwise immutable. That means that you always receive a copy of\nvalues and fields and modifying these copies will not affect the original\ncolumn object.\n\n```python\nfrom frictionless.fields import IntegerField\nfield = IntegerField(name=\"test\")\ncol = Column(field=field, values=[1, 2, 3])\nprint(col.value)  # returns [1, 2, 3]\nnew_items = col.values\nnew_items.append(4)\nprint(col.values)  # still returns [1, 2, 3]\ncol.values = new_items\nprint(col.values)  # returns [1, 2, 3, 4]\nnew_field = IntegerField(name=\"another_test\") # raises AttributeError\n```\n</code></pre> Source code in <code>sweet_validation/items/columns.py</code> <pre><code>class Column(ValidatedValues[list[Any]]):\n    \"\"\"A column is defined as a list of items and a frictionless Field object.\n\n    The field object defines the type and constraints of the column and is based\n    on the frictionless.Field object. Values are validated against this field\n    every time they are appended or extended.\n\n    For more information on the Field object, see:\n    - [Field types](https://framework.frictionlessdata.io/docs/fields/any.html)\n        under \"Data Fields\"\n    - [Constraints](https://specs.frictionlessdata.io/table-schema/#constraints)\n    - [Table and Field Scheme standard](https://datapackage.org/standard/table-schema/)\n\n    Attributes:\n        field (Field): A frictionless Field object.\n            The field object defines the type and constraints of the column.\n            It can only be modified during instantiation. Otherwise it is\n            immutable.\n        values (list): A list of items. The items are validated against the field\n            object. values are immutable and can only be set during instantiation or by\n            replacing the values (e.g., col.values = [1, 2, 3]) which triggers\n            a validation check.\n\n    Methods:\n        is_valid: Raise a ValidationError if values are not valid. It can also\n            be used to validate a list of items against the Field object.\n        validate: Validate values against the Field object.\n        get_resource: Return a frictionless Resource object with the values and\n            meta-data.\n\n    Raises:\n        ValidationError: If the items are not valid given the Field object.\n        AttributeError: If the fields are modified after instantiation.\n\n    Examples:\n\n        ```python\n        from frictionless.fields import IntegerField\n        field = IntegerField(name=\"test\", constraints={\"minimum\": 1, \"maximum\": 3})\n        col = Column(field=field, values=[1, 2, 3])\n        ```\n\n        The field property is immutable and values can only be replaced by a new list\n        but are otherwise immutable. That means that you always receive a copy of\n        values and fields and modifying these copies will not affect the original\n        column object.\n\n        ```python\n        from frictionless.fields import IntegerField\n        field = IntegerField(name=\"test\")\n        col = Column(field=field, values=[1, 2, 3])\n        print(col.value)  # returns [1, 2, 3]\n        new_items = col.values\n        new_items.append(4)\n        print(col.values)  # still returns [1, 2, 3]\n        col.values = new_items\n        print(col.values)  # returns [1, 2, 3, 4]\n        new_field = IntegerField(name=\"another_test\") # raises AttributeError\n        ```\n    \"\"\"\n\n    _values: list[Any] = []\n    _field: Field\n\n    def __init__(self, field: Field, values: list[Any] | None = None):\n        values = values or []\n        # first assign the field so the validation can be done, then call parent class\n        self._field = field\n        super().__init__(values=values)\n\n    @property\n    def field(self) -&gt; Field:\n        \"\"\"Return the field object of the column.\"\"\"\n        return self._field\n\n    @field.setter\n    def field(self, field: Field) -&gt; None:\n        \"\"\"Set the field object of the column.\"\"\"\n        raise AttributeError(\"Cannot reset the field. Create a new column instead.\")\n\n    def is_valid(\n        self, values: list[Any] | None = None, raise_exception: bool = True\n    ) -&gt; bool:\n        \"\"\"Raise a ValidationError if values are not valid.\n\n        Args:\n            values (list): A list of items. If None, the column values are used.\n            raise_exception (bool): If True, raise a ValidationError if values\n                are not valid. If False returns False if validation fails.\n\n        Returns:\n            bool: True if values are valid. False otherwise.\n\n        Raises:\n            ValidationError: If the items are not valid.\n        \"\"\"\n        values = values or self.values\n        rep = self.validate(values=values)\n        if not rep.valid:\n            if raise_exception:\n                raise ValidationError(report=rep)\n            return False\n        return True\n\n    def validate(self, values: list[Any] | None = None) -&gt; Report:\n        \"\"\"Validate a list of items against the Field object.\n\n        Args:\n            values (list): A list of items.\n\n        Raises:\n            ValueError: If the items are not valid.\n        \"\"\"\n        values = values or self.values\n        return self.get_resource(values=values).validate()\n\n    def get_resource(self, values: list[Any] | None) -&gt; Resource:\n        \"\"\"Return a Resource object with the column items.\n\n        Args:\n            values (list): A list of items. If None, the column items are used.\"\"\"\n        values = values or self.values\n        data = [[self.field.name]] + [[i] for i in values]\n        return Resource(data=data, schema=Schema(fields=[self.field]))\n</code></pre>"},{"location":"api/#sweet_validation.items.Column._field","title":"<code>_field = field</code>  <code>instance-attribute</code>","text":""},{"location":"api/#sweet_validation.items.Column._values","title":"<code>_values = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#sweet_validation.items.Column.field","title":"<code>field</code>  <code>property</code> <code>writable</code>","text":"<p>Return the field object of the column.</p>"},{"location":"api/#sweet_validation.items.Column.__init__","title":"<code>__init__(field, values=None)</code>","text":"Source code in <code>sweet_validation/items/columns.py</code> <pre><code>def __init__(self, field: Field, values: list[Any] | None = None):\n    values = values or []\n    # first assign the field so the validation can be done, then call parent class\n    self._field = field\n    super().__init__(values=values)\n</code></pre>"},{"location":"api/#sweet_validation.items.Column.get_resource","title":"<code>get_resource(values)</code>","text":"<p>Return a Resource object with the column items.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list</code> <p>A list of items. If None, the column items are used.</p> required Source code in <code>sweet_validation/items/columns.py</code> <pre><code>def get_resource(self, values: list[Any] | None) -&gt; Resource:\n    \"\"\"Return a Resource object with the column items.\n\n    Args:\n        values (list): A list of items. If None, the column items are used.\"\"\"\n    values = values or self.values\n    data = [[self.field.name]] + [[i] for i in values]\n    return Resource(data=data, schema=Schema(fields=[self.field]))\n</code></pre>"},{"location":"api/#sweet_validation.items.Column.is_valid","title":"<code>is_valid(values=None, raise_exception=True)</code>","text":"<p>Raise a ValidationError if values are not valid.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list</code> <p>A list of items. If None, the column values are used.</p> <code>None</code> <code>raise_exception</code> <code>bool</code> <p>If True, raise a ValidationError if values are not valid. If False returns False if validation fails.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if values are valid. False otherwise.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the items are not valid.</p> Source code in <code>sweet_validation/items/columns.py</code> <pre><code>def is_valid(\n    self, values: list[Any] | None = None, raise_exception: bool = True\n) -&gt; bool:\n    \"\"\"Raise a ValidationError if values are not valid.\n\n    Args:\n        values (list): A list of items. If None, the column values are used.\n        raise_exception (bool): If True, raise a ValidationError if values\n            are not valid. If False returns False if validation fails.\n\n    Returns:\n        bool: True if values are valid. False otherwise.\n\n    Raises:\n        ValidationError: If the items are not valid.\n    \"\"\"\n    values = values or self.values\n    rep = self.validate(values=values)\n    if not rep.valid:\n        if raise_exception:\n            raise ValidationError(report=rep)\n        return False\n    return True\n</code></pre>"},{"location":"api/#sweet_validation.items.Column.validate","title":"<code>validate(values=None)</code>","text":"<p>Validate a list of items against the Field object.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list</code> <p>A list of items.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the items are not valid.</p> Source code in <code>sweet_validation/items/columns.py</code> <pre><code>def validate(self, values: list[Any] | None = None) -&gt; Report:\n    \"\"\"Validate a list of items against the Field object.\n\n    Args:\n        values (list): A list of items.\n\n    Raises:\n        ValueError: If the items are not valid.\n    \"\"\"\n    values = values or self.values\n    return self.get_resource(values=values).validate()\n</code></pre>"}]}