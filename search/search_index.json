{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Sweet Validation","text":"<p>Sweet Validation is package to perform data validation within the Sweet CoSi project. To perform validation, the package relies on a description of data tables using yaml or json files. Data items are checked against the description provided in these files.</p> <p>To harmonize the description of data, Sweet Validation allows to set a standard for the data description, i.e., imposing a meta-data standard. By default this standard is set to the Frictionless Table Scheme. It is, however, possible to impose any standard as long as it is a valid json schema.</p> <p>To validate data, we rely on a Validator class (ADD LINK TO API DOCS) that mainly provides two methods:</p> <ol> <li>validate(data, schema): Takes a data item and a schema. Validating the data against the schema, it provides a validation report.</li> <li>is_valid(data, schema): Uses the validate method to return an indicator whether the data item is valid or not.</li> </ol> <p>The default Validator uses frictionless table schemas to validate pandas dataframes against the schema using the pandera package.</p> <p>Validators check data against schemas. They however do not maintain the relation between data and schema, i.e., which schema is bound to which data item. The SchemaManager (ADD LINK TO API DOCS) has two major tasks:</p> <ol> <li>Managing the relation between data items and schema</li> <li>Ensuring that all schemas comply with the meta-data standard.</li> </ol> <p>The Registry (ADD LINK TO API DOCS) combines the SchemaManager and Validator together with a Storage interface that is responsible to save the data:</p> <p></p> <p>By interacting with schemas and data through the registry, it ensures that no data exists without a schema. Furthermore, it ensure that every change in data is checked against the associated schema. Likewise, every schema update triggers a validation check for all associated data resources.</p>"},{"location":"api/api/","title":"Api Reference","text":""},{"location":"api/api/#protocols","title":"Protocols","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for storage backends</p> <p>Storage backends implement at the very least the following methods:</p> <p>Methods:</p> Name Description <code>save</code> <p>Save a value to the storage backend.</p> <code>load</code> <p>Load a value from the storage backend.</p> <code>delete</code> <p>Delete a value from the storage backend.</p> <code>exists</code> <p>Check if a value exists in the storage backend.</p> <code>list</code> <p>List all keys in the storage backend.</p> <code>replace</code> <p>Replace a value in the storage backend. This method is already implemented and calls delete and save.</p> Source code in <code>sweet_validation/storage/protocols.py</code> <pre><code>@runtime_checkable\nclass StorageProtocol(Protocol):\n    \"\"\"Protocol for storage backends\n\n    Storage backends implement at the very least the following methods:\n\n    Methods:\n        save: Save a value to the storage backend.\n        load: Load a value from the storage backend.\n        delete: Delete a value from the storage backend.\n        exists: Check if a value exists in the storage backend.\n        list: List all keys in the storage backend.\n        replace: Replace a value in the storage backend.\n            This method is already implemented and calls delete and save.\n    \"\"\"\n\n    def save(self, key: Any, value: Any, **kwargs: Any) -&gt; None: ...\n    def load(self, key: Any, **kwargs: Any) -&gt; Any: ...\n    def delete(self, key: Any, **kwargs: Any) -&gt; Any: ...\n    def exists(self, key: Any, **kwargs: Any) -&gt; bool: ...\n    def list(self) -&gt; list[Any]: ...\n    def replace(self, key: Any, value: Any, **kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.StorageProtocol.delete","title":"<code>delete(key, **kwargs)</code>","text":"Source code in <code>sweet_validation/storage/protocols.py</code> <pre><code>def delete(self, key: Any, **kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.StorageProtocol.exists","title":"<code>exists(key, **kwargs)</code>","text":"Source code in <code>sweet_validation/storage/protocols.py</code> <pre><code>def exists(self, key: Any, **kwargs: Any) -&gt; bool: ...\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.StorageProtocol.list","title":"<code>list()</code>","text":"Source code in <code>sweet_validation/storage/protocols.py</code> <pre><code>def list(self) -&gt; list[Any]: ...\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.StorageProtocol.load","title":"<code>load(key, **kwargs)</code>","text":"Source code in <code>sweet_validation/storage/protocols.py</code> <pre><code>def load(self, key: Any, **kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.StorageProtocol.replace","title":"<code>replace(key, value, **kwargs)</code>","text":"Source code in <code>sweet_validation/storage/protocols.py</code> <pre><code>def replace(self, key: Any, value: Any, **kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.StorageProtocol.save","title":"<code>save(key, value, **kwargs)</code>","text":"Source code in <code>sweet_validation/storage/protocols.py</code> <pre><code>def save(self, key: Any, value: Any, **kwargs: Any) -&gt; None: ...\n</code></pre>"},{"location":"api/api/#classes","title":"Classes","text":""},{"location":"api/api/#registries","title":"Registries","text":"Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>class InMemoryRegistry:\n    _schema_manager: SchemaManager\n    _data_store: InMemoryStorage\n    _validator: Any\n\n    def __init__(self, validator: Any, schema_manager: SchemaManager) -&gt; None:\n        \"\"\"Initialize the registry with schema manager and storage\n\n        Args:\n            validator (Any): Validator to validate data against schema\n            fn_schema_db (str | None, optional): Filename of schema database.\n                Defaults to None.\n        \"\"\"\n        self._schema_manager = schema_manager\n        self._validator = validator\n        self._data_store = InMemoryStorage()\n\n    # -------- schema related methods\n    def add_schema(self, key: str, schema: Any) -&gt; None:\n        \"\"\"Add schema to the registry. The schema is validated against the metadata\n        standard. If the schema already exists, a KeyError is raised.\n\n        Args:\n            key (str): Key of schema\n            schema (Any): Schema to be added\n\n        Raises:\n            KeyError: If the schema already exists\n        \"\"\"\n        # TODO check schema against metadata standard\n        # --&gt; Done by schema manager?\n        self._schema_manager.add_schema(key=key, schema=schema)\n\n    def get_schema(self, key: str) -&gt; Any:\n        \"\"\"Given the key of schema, return the schema\n\n        Args:\n            key (str): Key of schema\n\n        Returns:\n            Any: Schema\n\n        Raises:\n            KeyError: If the schema does not exist\n        \"\"\"\n        return self._schema_manager[key]\n\n    def delete_schema(self, key: str) -&gt; None:\n        \"\"\"Given the key of schema delete it\n\n        Args:\n            key (str): Key of schema to delete\n\n        Raises:\n            ValueError: If the schema does not exist or data associated with\n                the schema still exist\n        \"\"\"\n        self._schema_manager.delete_schema(key=key)\n\n    def replace_schema(self, key: str, schema: Any) -&gt; None:\n        \"\"\"Replace a schema in the registry\n\n        Args:\n            key (str): Key of schema\n            schema (Any): New schema\n\n        Raises:\n            KeyError: If the schema does not exist\n            DataValidationError: If the data does not conform to the schema\n        \"\"\"\n        # ensure that new schema is valid\n        self._schema_manager.validate_schema(schema)\n        for data_key in self._schema_manager.list_data_for_schema(key):\n            data = self.get_data(data_key)\n            self._validate_data(data=data, schema=schema)\n        # replacement\n        self._schema_manager.replace_schema(key, schema)\n\n    @property\n    def schemas(self) -&gt; list[str]:\n        \"\"\"List all schemas\n\n        Returns:\n            list[str]: List of schema keys\n        \"\"\"\n        return self._schema_manager.schemas\n\n    # -------- data related methods\n    def add_data(self, key: str, schema_key: str, data: Any) -&gt; None:\n        \"\"\"Add data to the registry. The data is validated given the schema.\n\n        Args:\n            key (str): Key of data\n            schema_key (str): Key of schema\n            data (Any): Data to be added\n\n        Raises:\n            KeyError: If the schema does not exist\n        \"\"\"\n        if key in self._schema_manager.data:\n            raise KeyError(f\"Data {key} already exists\")\n        if schema_key not in self.schemas:\n            raise KeyError(f\"Schema {schema_key} does not exist\")\n        # validate data\n        self._validate_data(data=data, schema=self.get_schema(schema_key))\n        # add data\n        self._schema_manager.add_data(key=key, key_schema=schema_key)\n        self._data_store.save(key, data)\n\n    def get_data(self, key: str) -&gt; Any:\n        \"\"\"Given the key of data, return the data\n\n        Args:\n            key (str): Key of data\n\n        Returns:\n            Any: Data\n\n        Raises:\n            KeyError: If the data does not exist\n        \"\"\"\n        return self._data_store.load(key)\n\n    def delete_data(self, key: str) -&gt; None:\n        \"\"\"Given the key of data delete it\n\n        Args:\n            key (str): Key of data to delete\n\n        Raises:\n            IntegrityError: If the data does not exist\n        \"\"\"\n        self._schema_manager.delete_data(key=key)\n        self._data_store.delete(key)\n\n    def replace_data(self, key: str, data: Any) -&gt; None:\n        \"\"\"Replace a data in the registry\n\n        Args:\n            key (str): Key of data\n            data (Any): New data\n\n        Raises:\n            KeyError: If the data does not exist\n            ValidationError: If the data does not conform to the schema\n        \"\"\"\n        schema = self._schema_manager.get_data_schema(key)\n        # check data against schema\n        self._validate_data(data=data, schema=schema)\n        # replacement\n        self._data_store.replace(key, data)\n\n    def list_data(self) -&gt; list[tuple[str, str]]:\n        \"\"\"List all data\n\n        Returns:\n            list[tuple[str, str]]: List of data tuples (id, id_schema)\n\n        Raises:\n            IntegrityError: If the data does not exist\n        \"\"\"\n        return self._schema_manager.list_data()\n\n    def _validate_data(self, data: Any, schema: dict[str, Any]) -&gt; None:\n        \"\"\"Validate data against schema\n\n        Args:\n            data (Any): Data to be validated\n            schema (dict[str, Any]): Schema to validate against\n\n        Raises:\n            DataValidationError: If data does not conform to schema\n        \"\"\"\n        # check data against schema\n        if not self._validator.is_valid(data, schema):\n            raise DataValidationError(\"Data does not conform to schema\")\n\n    @property\n    def data(self) -&gt; list[str]:\n        \"\"\"List all data keys\n\n        Returns:\n            list[str]: List of data keys\n        \"\"\"\n        return self._schema_manager.data\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry._data_store","title":"<code>_data_store = InMemoryStorage()</code>  <code>instance-attribute</code>","text":""},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry._schema_manager","title":"<code>_schema_manager = schema_manager</code>  <code>instance-attribute</code>","text":""},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry._validator","title":"<code>_validator = validator</code>  <code>instance-attribute</code>","text":""},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.data","title":"<code>data</code>  <code>property</code>","text":"<p>List all data keys</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of data keys</p>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.schemas","title":"<code>schemas</code>  <code>property</code>","text":"<p>List all schemas</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of schema keys</p>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.__init__","title":"<code>__init__(validator, schema_manager)</code>","text":"<p>Initialize the registry with schema manager and storage</p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>Any</code> <p>Validator to validate data against schema</p> required <code>fn_schema_db</code> <code>str | None</code> <p>Filename of schema database. Defaults to None.</p> required Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def __init__(self, validator: Any, schema_manager: SchemaManager) -&gt; None:\n    \"\"\"Initialize the registry with schema manager and storage\n\n    Args:\n        validator (Any): Validator to validate data against schema\n        fn_schema_db (str | None, optional): Filename of schema database.\n            Defaults to None.\n    \"\"\"\n    self._schema_manager = schema_manager\n    self._validator = validator\n    self._data_store = InMemoryStorage()\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry._validate_data","title":"<code>_validate_data(data, schema)</code>","text":"<p>Validate data against schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to be validated</p> required <code>schema</code> <code>dict[str, Any]</code> <p>Schema to validate against</p> required <p>Raises:</p> Type Description <code>DataValidationError</code> <p>If data does not conform to schema</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def _validate_data(self, data: Any, schema: dict[str, Any]) -&gt; None:\n    \"\"\"Validate data against schema\n\n    Args:\n        data (Any): Data to be validated\n        schema (dict[str, Any]): Schema to validate against\n\n    Raises:\n        DataValidationError: If data does not conform to schema\n    \"\"\"\n    # check data against schema\n    if not self._validator.is_valid(data, schema):\n        raise DataValidationError(\"Data does not conform to schema\")\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.add_data","title":"<code>add_data(key, schema_key, data)</code>","text":"<p>Add data to the registry. The data is validated given the schema.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data</p> required <code>schema_key</code> <code>str</code> <p>Key of schema</p> required <code>data</code> <code>Any</code> <p>Data to be added</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def add_data(self, key: str, schema_key: str, data: Any) -&gt; None:\n    \"\"\"Add data to the registry. The data is validated given the schema.\n\n    Args:\n        key (str): Key of data\n        schema_key (str): Key of schema\n        data (Any): Data to be added\n\n    Raises:\n        KeyError: If the schema does not exist\n    \"\"\"\n    if key in self._schema_manager.data:\n        raise KeyError(f\"Data {key} already exists\")\n    if schema_key not in self.schemas:\n        raise KeyError(f\"Schema {schema_key} does not exist\")\n    # validate data\n    self._validate_data(data=data, schema=self.get_schema(schema_key))\n    # add data\n    self._schema_manager.add_data(key=key, key_schema=schema_key)\n    self._data_store.save(key, data)\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.add_schema","title":"<code>add_schema(key, schema)</code>","text":"<p>Add schema to the registry. The schema is validated against the metadata standard. If the schema already exists, a KeyError is raised.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema</p> required <code>schema</code> <code>Any</code> <p>Schema to be added</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema already exists</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def add_schema(self, key: str, schema: Any) -&gt; None:\n    \"\"\"Add schema to the registry. The schema is validated against the metadata\n    standard. If the schema already exists, a KeyError is raised.\n\n    Args:\n        key (str): Key of schema\n        schema (Any): Schema to be added\n\n    Raises:\n        KeyError: If the schema already exists\n    \"\"\"\n    # TODO check schema against metadata standard\n    # --&gt; Done by schema manager?\n    self._schema_manager.add_schema(key=key, schema=schema)\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.delete_data","title":"<code>delete_data(key)</code>","text":"<p>Given the key of data delete it</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data to delete</p> required <p>Raises:</p> Type Description <code>IntegrityError</code> <p>If the data does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def delete_data(self, key: str) -&gt; None:\n    \"\"\"Given the key of data delete it\n\n    Args:\n        key (str): Key of data to delete\n\n    Raises:\n        IntegrityError: If the data does not exist\n    \"\"\"\n    self._schema_manager.delete_data(key=key)\n    self._data_store.delete(key)\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.delete_schema","title":"<code>delete_schema(key)</code>","text":"<p>Given the key of schema delete it</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the schema does not exist or data associated with the schema still exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def delete_schema(self, key: str) -&gt; None:\n    \"\"\"Given the key of schema delete it\n\n    Args:\n        key (str): Key of schema to delete\n\n    Raises:\n        ValueError: If the schema does not exist or data associated with\n            the schema still exist\n    \"\"\"\n    self._schema_manager.delete_schema(key=key)\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.get_data","title":"<code>get_data(key)</code>","text":"<p>Given the key of data, return the data</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Data</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def get_data(self, key: str) -&gt; Any:\n    \"\"\"Given the key of data, return the data\n\n    Args:\n        key (str): Key of data\n\n    Returns:\n        Any: Data\n\n    Raises:\n        KeyError: If the data does not exist\n    \"\"\"\n    return self._data_store.load(key)\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.get_schema","title":"<code>get_schema(key)</code>","text":"<p>Given the key of schema, return the schema</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Schema</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def get_schema(self, key: str) -&gt; Any:\n    \"\"\"Given the key of schema, return the schema\n\n    Args:\n        key (str): Key of schema\n\n    Returns:\n        Any: Schema\n\n    Raises:\n        KeyError: If the schema does not exist\n    \"\"\"\n    return self._schema_manager[key]\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.list_data","title":"<code>list_data()</code>","text":"<p>List all data</p> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: List of data tuples (id, id_schema)</p> <p>Raises:</p> Type Description <code>IntegrityError</code> <p>If the data does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def list_data(self) -&gt; list[tuple[str, str]]:\n    \"\"\"List all data\n\n    Returns:\n        list[tuple[str, str]]: List of data tuples (id, id_schema)\n\n    Raises:\n        IntegrityError: If the data does not exist\n    \"\"\"\n    return self._schema_manager.list_data()\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.replace_data","title":"<code>replace_data(key, data)</code>","text":"<p>Replace a data in the registry</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data</p> required <code>data</code> <code>Any</code> <p>New data</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data does not exist</p> <code>ValidationError</code> <p>If the data does not conform to the schema</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def replace_data(self, key: str, data: Any) -&gt; None:\n    \"\"\"Replace a data in the registry\n\n    Args:\n        key (str): Key of data\n        data (Any): New data\n\n    Raises:\n        KeyError: If the data does not exist\n        ValidationError: If the data does not conform to the schema\n    \"\"\"\n    schema = self._schema_manager.get_data_schema(key)\n    # check data against schema\n    self._validate_data(data=data, schema=schema)\n    # replacement\n    self._data_store.replace(key, data)\n</code></pre>"},{"location":"api/api/#sweet_validation.registry.InMemoryRegistry.replace_schema","title":"<code>replace_schema(key, schema)</code>","text":"<p>Replace a schema in the registry</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema</p> required <code>schema</code> <code>Any</code> <p>New schema</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema does not exist</p> <code>DataValidationError</code> <p>If the data does not conform to the schema</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def replace_schema(self, key: str, schema: Any) -&gt; None:\n    \"\"\"Replace a schema in the registry\n\n    Args:\n        key (str): Key of schema\n        schema (Any): New schema\n\n    Raises:\n        KeyError: If the schema does not exist\n        DataValidationError: If the data does not conform to the schema\n    \"\"\"\n    # ensure that new schema is valid\n    self._schema_manager.validate_schema(schema)\n    for data_key in self._schema_manager.list_data_for_schema(key):\n        data = self.get_data(data_key)\n        self._validate_data(data=data, schema=schema)\n    # replacement\n    self._schema_manager.replace_schema(key, schema)\n</code></pre>"},{"location":"api/api/#schema-manager","title":"Schema Manager","text":"<p>A simple relation manager based on SQLite</p> <p>The underlying database is in-memory if no filename is provided. If a filename is provided, the database is stored in the file. The database has two tables: Schema and Data. The schema table stores the schema key and the schema itself. The data table stores the data key and the schema key associated with the data. Note that data table does not store data but only the key to access the data.</p> <p>Attributes:</p> Name Type Description <code>schemas</code> <code>list[str]</code> <p>List of schema keys</p> <p>Methods:</p> Name Description <code>add_schema</code> <p>Insert a schema into the database</p> <code>delete_schema</code> <p>Delete a schema given the key</p> <code>replace_schema</code> <p>Replace a schema in the database</p> <code>list_data_for_schema</code> <p>Get the data keys associated with the schema key</p> <code>add_data</code> <p>Insert data into the database</p> <code>list_data</code> <p>Fetch all data keys</p> <code>delete_data</code> <p>Delete data given the key</p> <code>get_data_schema</code> <p>Get the schema key associated with the data key</p> <code>get_session</code> <p>Provides a context-managed database session</p> <code>close_engine</code> <p>Close the database engine</p> <code>close</code> <p>Close the database engine</p> <code>clear</code> <p>Clear all tables in the database</p> <code>clear_and_close</code> <p>Clear all data and close the database engine</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>class SchemaManager:\n    \"\"\"A simple relation manager based on SQLite\n\n    The underlying database is in-memory if no filename is provided.\n    If a filename is provided, the database is stored in the file.\n    The database has two tables: Schema and Data. The schema table stores the\n    schema key and the schema itself. The data table stores the data key and the\n    schema key associated with the data. Note that data table does not store data\n    but only the key to access the data.\n\n    Attributes:\n        schemas: List of schema keys\n\n    Methods:\n        # schema management methods\n        add_schema: Insert a schema into the database\n        delete_schema: Delete a schema given the key\n        replace_schema: Replace a schema in the database\n        list_data_for_schema: Get the data keys associated with the schema key\n\n        # data management methods\n        add_data: Insert data into the database\n        list_data: Fetch all data keys\n        delete_data: Delete data given the key\n        get_data_schema: Get the schema key associated with the data key\n\n        # db management methods\n        get_session: Provides a context-managed database session\n        close_engine: Close the database engine\n        close: Close the database engine\n        clear: Clear all tables in the database\n        clear_and_close: Clear all data and close the database engine\n    \"\"\"\n\n    def __init__(\n        self,\n        fn_db: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the database engine and session factory\n        Args:\n            fn (str | None): Filename of the sqlite database\n                Defaults to None, which uses an in-memory database\n            meta_schema (str | Schema | None): Metadata schema for the database\n                Defaults to None, which uses the default schema. If a string is\n                provided it is assumed to be a path to a schema file in yaml format.\n        \"\"\"\n        # create the meta-data schema\n        # TODO allow for extensions of the base schema\n        self._meta_schema: dict[str, Any] = read_json_or_yaml(BASE_SCHEMA)\n\n        # self._meta_schema = self._create_schema_from_file(meta_schema)\n        # create the engine and the tables\n        conn_str = f\"sqlite:///{fn_db}\" if fn_db else \"sqlite:///:memory:\"\n        self._init_db(conn_str)\n\n    def _create_and_check_schema(\n        self, schema: str | Path | dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a schema from file and return the scheme itself it is already a\n        schema\n\n        Args:\n            schema (str | Path | dict[str, Any]): Schema\n                If a string or pathlib.Path is provided, it is assumed to be the\n                path to a schema file in json or yaml format\n\n        Returns:\n            dict[str, Any]: Schema\n        \"\"\"\n        if isinstance(schema, str | Path):\n            schema = read_json_or_yaml(schema)\n        self.validate_schema(schema)\n        return schema\n\n    # --------- schema management methods\n    @property\n    def schemas(self) -&gt; list[str]:\n        \"\"\"Fetch all schema keys\n\n        Returns:\n            list[str]: List of schema keys\n        \"\"\"\n        with self.get_session() as session:\n            return [schema.id for schema in session.query(SchemaTable).all()]\n\n    def __getitem__(self, key: str) -&gt; dict[str, Any]:\n        \"\"\"Get the schema given the key\n\n        Args:\n            key (str): Schema key\n\n        Raises:\n            KeyError: If the schema key does not exist\n\n        Returns:\n            str: Schema\n        \"\"\"\n        with self.get_session() as session:\n            schema = session.query(SchemaTable).filter(SchemaTable.id == key).first()\n            if not schema:\n                raise KeyError(f\"Schema key '{key}' not found\")\n            return cast(dict[str, Any], json.loads(schema.schema))\n\n    def add_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n        \"\"\"Insert a schema into the database given the key\n\n        Args:\n            key (str): Schema key\n            schema (str | Path | dict[str, Any]): Schema\n                If a string or pathlib.Path is provided, it is assumed to be the\n                path to a schema file in json or yaml format.\n\n        Raises:\n            KeyError: If the schema key already exists\n        \"\"\"\n        if key in self.schemas:\n            raise KeyError(f\"Schema key '{key}' already exists\")\n\n        schema = self._create_and_check_schema(schema)\n\n        # convert schema to json string and store in database\n        schema = json.dumps(schema)\n        with self.get_session() as session:\n            session.add(SchemaTable(id=key, schema=schema))\n            session.commit()\n\n    def delete_schema(self, key: str) -&gt; None:\n        \"\"\"Delete a schema given the key\n\n        Args:\n            key (str): Schema key\n\n        Raises:\n            KeyError: If schema does not exist\n            ValueError: If some data is still associated with the schema\n        \"\"\"\n        if key not in self.schemas:\n            raise KeyError(f\"Schema key '{key}' not found\")\n        if self.list_data_for_schema(key):\n            raise ValueError(f\"Data associated with schema key '{key}' still exists\")\n        with self.get_session() as session:\n            session.query(SchemaTable).filter(SchemaTable.id == key).delete()\n            session.commit()\n\n    def replace_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n        \"\"\"Replace a schema in the database\n\n        Args:\n            key (str): Schema key\n            schema (str | Schema): New schema\n\n        Raises:\n            KeyError: If the schema key does not exist\n        \"\"\"\n        if key not in self.schemas:\n            raise KeyError(f\"Schema key '{key}' not found\")\n\n        schema = self._create_and_check_schema(schema)\n\n        schema = json.dumps(schema)\n        with self.get_session() as session:\n            session.query(SchemaTable).filter(SchemaTable.id == key).update(\n                {\"schema\": schema}\n            )\n            session.commit()\n\n    def list_data_for_schema(self, key: str) -&gt; list[str]:\n        \"\"\"Get the data keys associated with the schema key\n\n        Args:\n            key (str): Schema key\n\n        Returns:\n            list[str]: List of data keys\n        \"\"\"\n        with self.get_session() as session:\n            data = session.query(DataTable).filter(DataTable.id_schema == key).all()\n            return [str(d.id) for d in data]\n\n    def validate_schema(self, schema: str | Path | dict[str, Any]) -&gt; None:\n        \"\"\"Check if a schema is valid given the metadata schema\n\n        Args:\n            schema (str | Path | dict[str, Any]): Schema to check\n                If a string or pathlib.Path is provided, it is assumed to be the\n                path to a schema file in json or yaml format.\n\n        Raises:\n            jsonschema.exceptions.ValidationError: If the schema is not valid\n        \"\"\"\n        if isinstance(schema, str | Path):\n            schema = read_json_or_yaml(schema)\n        jsonschema.validate(instance=schema, schema=self._meta_schema)\n\n    # --------- data management methods\n    @property\n    def data(self) -&gt; list[str]:\n        \"\"\"List of all data keys\n\n        Returns:\n            list[str]: List of data keys\n        \"\"\"\n        return [d[0] for d in self.list_data()]\n\n    def add_data(self, key: str, key_schema: str) -&gt; None:\n        \"\"\"Insert data into the database given the key and key of associated schema\n\n        Args:\n            key (str): Data key\n            key_schema (str): Schema key\n\n        Raises:\n            KeyError: If the primary key or foreign constraint is violated\n        \"\"\"\n        if key in self.data:\n            raise KeyError(f\"Data key '{key}' already exists\")\n        if key_schema not in self.schemas:\n            raise KeyError(f\"Schema key '{key_schema}' not found\")\n        with self.get_session() as session:\n            session.add(DataTable(id=key, id_schema=key_schema))\n            session.commit()\n\n    def list_data(self) -&gt; list[tuple[str, str]]:\n        \"\"\"Fetch all data\n\n        Returns:\n            list[tuple[str, str]]: List of data tuples (id, id_schema)\n        \"\"\"\n        with self.get_session() as session:\n            return [\n                (data.id, data.id_schema) for data in session.query(DataTable).all()\n            ]\n\n    def delete_data(self, key: str) -&gt; None:\n        \"\"\"Delete data given the key\n\n        Args:\n            key (str): Data key\n\n        Raises:\n            KeyError: If the data key does not exist\n        \"\"\"\n        if key not in [d[0] for d in self.list_data()]:\n            raise KeyError(f\"Data key '{key}' not found\")\n        with self.get_session() as session:\n            session.query(DataTable).filter(DataTable.id == key).delete()\n            session.commit()\n\n    # todo fix output type here\n    def get_data_schema(self, key: str) -&gt; dict[str, Any]:\n        \"\"\"Get the schema key associated with the data key\n\n        Args:\n            key (str): Data key\n\n        raises:\n            KeyError: If the data key does not exist\n\n        Returns:\n            str: Schema\n        \"\"\"\n        key_schema = self.get_data_schema_key(key)\n        return self[key_schema]\n\n    def get_data_schema_key(self, key: str) -&gt; str:\n        \"\"\"Get the schema key associated with the data key\n\n        Args:\n            key (str): Data key\n\n        raises:\n            KeyError: If the data key does not exist\n\n        Returns:\n            str: Schema key\n        \"\"\"\n        with self.get_session() as session:\n            data = session.query(DataTable).filter(DataTable.id == key).first()\n            if not data:\n                raise KeyError(f\"Data key '{key}' not found\")\n            return str(data.id_schema)\n\n    # --------- db management methods\n    def _init_db(self, conn_str: str) -&gt; None:\n        \"\"\"Initialize the database with the metadata schema\n\n        Args:\n            conn_str (str): Connection string to the database\n        \"\"\"\n        self._conn_str = conn_str\n        self._engine = create_engine(self._conn_str)\n        Base.metadata.create_all(self._engine)  # Create tables if they don't exist\n        self._SessionLocal = sessionmaker(bind=self._engine)  # Create session factory\n\n    def _close_engine(self) -&gt; None:\n        \"\"\"Close the database engine.\"\"\"\n        self._engine.dispose()\n        self._engine = None\n\n    def close(self) -&gt; None:\n        self._close_engine()\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all data in the database\"\"\"\n        with self.get_session() as session:\n            session.query(DataTable).delete()\n            session.query(SchemaTable).delete()\n            session.commit()\n\n    def clear_and_close(self) -&gt; None:\n        self.clear()\n        self.close()\n\n    @contextmanager\n    def get_session(self) -&gt; Generator[Session, None, None]:\n        \"\"\"Provides a context-managed database session.\"\"\"\n        session = self._SessionLocal()\n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            session.rollback()\n            raise e  # Re-raise after rollback\n        finally:\n            session.close()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager._meta_schema","title":"<code>_meta_schema = read_json_or_yaml(BASE_SCHEMA)</code>  <code>instance-attribute</code>","text":""},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.data","title":"<code>data</code>  <code>property</code>","text":"<p>List of all data keys</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of data keys</p>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.schemas","title":"<code>schemas</code>  <code>property</code>","text":"<p>Fetch all schema keys</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of schema keys</p>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the schema given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema key does not exist</p> <p>Returns:</p> Name Type Description <code>str</code> <code>dict[str, Any]</code> <p>Schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def __getitem__(self, key: str) -&gt; dict[str, Any]:\n    \"\"\"Get the schema given the key\n\n    Args:\n        key (str): Schema key\n\n    Raises:\n        KeyError: If the schema key does not exist\n\n    Returns:\n        str: Schema\n    \"\"\"\n    with self.get_session() as session:\n        schema = session.query(SchemaTable).filter(SchemaTable.id == key).first()\n        if not schema:\n            raise KeyError(f\"Schema key '{key}' not found\")\n        return cast(dict[str, Any], json.loads(schema.schema))\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.__init__","title":"<code>__init__(fn_db=None)</code>","text":"<p>Initialize the database engine and session factory Args:     fn (str | None): Filename of the sqlite database         Defaults to None, which uses an in-memory database     meta_schema (str | Schema | None): Metadata schema for the database         Defaults to None, which uses the default schema. If a string is         provided it is assumed to be a path to a schema file in yaml format.</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def __init__(\n    self,\n    fn_db: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the database engine and session factory\n    Args:\n        fn (str | None): Filename of the sqlite database\n            Defaults to None, which uses an in-memory database\n        meta_schema (str | Schema | None): Metadata schema for the database\n            Defaults to None, which uses the default schema. If a string is\n            provided it is assumed to be a path to a schema file in yaml format.\n    \"\"\"\n    # create the meta-data schema\n    # TODO allow for extensions of the base schema\n    self._meta_schema: dict[str, Any] = read_json_or_yaml(BASE_SCHEMA)\n\n    # self._meta_schema = self._create_schema_from_file(meta_schema)\n    # create the engine and the tables\n    conn_str = f\"sqlite:///{fn_db}\" if fn_db else \"sqlite:///:memory:\"\n    self._init_db(conn_str)\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager._close_engine","title":"<code>_close_engine()</code>","text":"<p>Close the database engine.</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def _close_engine(self) -&gt; None:\n    \"\"\"Close the database engine.\"\"\"\n    self._engine.dispose()\n    self._engine = None\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager._create_and_check_schema","title":"<code>_create_and_check_schema(schema)</code>","text":"<p>Create a schema from file and return the scheme itself it is already a schema</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str | Path | dict[str, Any]</code> <p>Schema If a string or pathlib.Path is provided, it is assumed to be the path to a schema file in json or yaml format</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def _create_and_check_schema(\n    self, schema: str | Path | dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Create a schema from file and return the scheme itself it is already a\n    schema\n\n    Args:\n        schema (str | Path | dict[str, Any]): Schema\n            If a string or pathlib.Path is provided, it is assumed to be the\n            path to a schema file in json or yaml format\n\n    Returns:\n        dict[str, Any]: Schema\n    \"\"\"\n    if isinstance(schema, str | Path):\n        schema = read_json_or_yaml(schema)\n    self.validate_schema(schema)\n    return schema\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager._init_db","title":"<code>_init_db(conn_str)</code>","text":"<p>Initialize the database with the metadata schema</p> <p>Parameters:</p> Name Type Description Default <code>conn_str</code> <code>str</code> <p>Connection string to the database</p> required Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def _init_db(self, conn_str: str) -&gt; None:\n    \"\"\"Initialize the database with the metadata schema\n\n    Args:\n        conn_str (str): Connection string to the database\n    \"\"\"\n    self._conn_str = conn_str\n    self._engine = create_engine(self._conn_str)\n    Base.metadata.create_all(self._engine)  # Create tables if they don't exist\n    self._SessionLocal = sessionmaker(bind=self._engine)  # Create session factory\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.add_data","title":"<code>add_data(key, key_schema)</code>","text":"<p>Insert data into the database given the key and key of associated schema</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <code>key_schema</code> <code>str</code> <p>Schema key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the primary key or foreign constraint is violated</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def add_data(self, key: str, key_schema: str) -&gt; None:\n    \"\"\"Insert data into the database given the key and key of associated schema\n\n    Args:\n        key (str): Data key\n        key_schema (str): Schema key\n\n    Raises:\n        KeyError: If the primary key or foreign constraint is violated\n    \"\"\"\n    if key in self.data:\n        raise KeyError(f\"Data key '{key}' already exists\")\n    if key_schema not in self.schemas:\n        raise KeyError(f\"Schema key '{key_schema}' not found\")\n    with self.get_session() as session:\n        session.add(DataTable(id=key, id_schema=key_schema))\n        session.commit()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.add_schema","title":"<code>add_schema(key, schema)</code>","text":"<p>Insert a schema into the database given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <code>schema</code> <code>str | Path | dict[str, Any]</code> <p>Schema If a string or pathlib.Path is provided, it is assumed to be the path to a schema file in json or yaml format.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema key already exists</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def add_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n    \"\"\"Insert a schema into the database given the key\n\n    Args:\n        key (str): Schema key\n        schema (str | Path | dict[str, Any]): Schema\n            If a string or pathlib.Path is provided, it is assumed to be the\n            path to a schema file in json or yaml format.\n\n    Raises:\n        KeyError: If the schema key already exists\n    \"\"\"\n    if key in self.schemas:\n        raise KeyError(f\"Schema key '{key}' already exists\")\n\n    schema = self._create_and_check_schema(schema)\n\n    # convert schema to json string and store in database\n    schema = json.dumps(schema)\n    with self.get_session() as session:\n        session.add(SchemaTable(id=key, schema=schema))\n        session.commit()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.clear","title":"<code>clear()</code>","text":"<p>Clear all data in the database</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all data in the database\"\"\"\n    with self.get_session() as session:\n        session.query(DataTable).delete()\n        session.query(SchemaTable).delete()\n        session.commit()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.clear_and_close","title":"<code>clear_and_close()</code>","text":"Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def clear_and_close(self) -&gt; None:\n    self.clear()\n    self.close()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.close","title":"<code>close()</code>","text":"Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def close(self) -&gt; None:\n    self._close_engine()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.delete_data","title":"<code>delete_data(key)</code>","text":"<p>Delete data given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data key does not exist</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def delete_data(self, key: str) -&gt; None:\n    \"\"\"Delete data given the key\n\n    Args:\n        key (str): Data key\n\n    Raises:\n        KeyError: If the data key does not exist\n    \"\"\"\n    if key not in [d[0] for d in self.list_data()]:\n        raise KeyError(f\"Data key '{key}' not found\")\n    with self.get_session() as session:\n        session.query(DataTable).filter(DataTable.id == key).delete()\n        session.commit()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.delete_schema","title":"<code>delete_schema(key)</code>","text":"<p>Delete a schema given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If schema does not exist</p> <code>ValueError</code> <p>If some data is still associated with the schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def delete_schema(self, key: str) -&gt; None:\n    \"\"\"Delete a schema given the key\n\n    Args:\n        key (str): Schema key\n\n    Raises:\n        KeyError: If schema does not exist\n        ValueError: If some data is still associated with the schema\n    \"\"\"\n    if key not in self.schemas:\n        raise KeyError(f\"Schema key '{key}' not found\")\n    if self.list_data_for_schema(key):\n        raise ValueError(f\"Data associated with schema key '{key}' still exists\")\n    with self.get_session() as session:\n        session.query(SchemaTable).filter(SchemaTable.id == key).delete()\n        session.commit()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.get_data_schema","title":"<code>get_data_schema(key)</code>","text":"<p>Get the schema key associated with the data key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data key does not exist</p> <p>Returns:</p> Name Type Description <code>str</code> <code>dict[str, Any]</code> <p>Schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def get_data_schema(self, key: str) -&gt; dict[str, Any]:\n    \"\"\"Get the schema key associated with the data key\n\n    Args:\n        key (str): Data key\n\n    raises:\n        KeyError: If the data key does not exist\n\n    Returns:\n        str: Schema\n    \"\"\"\n    key_schema = self.get_data_schema_key(key)\n    return self[key_schema]\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.get_data_schema_key","title":"<code>get_data_schema_key(key)</code>","text":"<p>Get the schema key associated with the data key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data key does not exist</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Schema key</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def get_data_schema_key(self, key: str) -&gt; str:\n    \"\"\"Get the schema key associated with the data key\n\n    Args:\n        key (str): Data key\n\n    raises:\n        KeyError: If the data key does not exist\n\n    Returns:\n        str: Schema key\n    \"\"\"\n    with self.get_session() as session:\n        data = session.query(DataTable).filter(DataTable.id == key).first()\n        if not data:\n            raise KeyError(f\"Data key '{key}' not found\")\n        return str(data.id_schema)\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.get_session","title":"<code>get_session()</code>","text":"<p>Provides a context-managed database session.</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>@contextmanager\ndef get_session(self) -&gt; Generator[Session, None, None]:\n    \"\"\"Provides a context-managed database session.\"\"\"\n    session = self._SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e  # Re-raise after rollback\n    finally:\n        session.close()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.list_data","title":"<code>list_data()</code>","text":"<p>Fetch all data</p> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: List of data tuples (id, id_schema)</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def list_data(self) -&gt; list[tuple[str, str]]:\n    \"\"\"Fetch all data\n\n    Returns:\n        list[tuple[str, str]]: List of data tuples (id, id_schema)\n    \"\"\"\n    with self.get_session() as session:\n        return [\n            (data.id, data.id_schema) for data in session.query(DataTable).all()\n        ]\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.list_data_for_schema","title":"<code>list_data_for_schema(key)</code>","text":"<p>Get the data keys associated with the schema key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of data keys</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def list_data_for_schema(self, key: str) -&gt; list[str]:\n    \"\"\"Get the data keys associated with the schema key\n\n    Args:\n        key (str): Schema key\n\n    Returns:\n        list[str]: List of data keys\n    \"\"\"\n    with self.get_session() as session:\n        data = session.query(DataTable).filter(DataTable.id_schema == key).all()\n        return [str(d.id) for d in data]\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.replace_schema","title":"<code>replace_schema(key, schema)</code>","text":"<p>Replace a schema in the database</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <code>schema</code> <code>str | Schema</code> <p>New schema</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema key does not exist</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def replace_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n    \"\"\"Replace a schema in the database\n\n    Args:\n        key (str): Schema key\n        schema (str | Schema): New schema\n\n    Raises:\n        KeyError: If the schema key does not exist\n    \"\"\"\n    if key not in self.schemas:\n        raise KeyError(f\"Schema key '{key}' not found\")\n\n    schema = self._create_and_check_schema(schema)\n\n    schema = json.dumps(schema)\n    with self.get_session() as session:\n        session.query(SchemaTable).filter(SchemaTable.id == key).update(\n            {\"schema\": schema}\n        )\n        session.commit()\n</code></pre>"},{"location":"api/api/#sweet_validation.schema_manager.SchemaManager.validate_schema","title":"<code>validate_schema(schema)</code>","text":"<p>Check if a schema is valid given the metadata schema</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str | Path | dict[str, Any]</code> <p>Schema to check If a string or pathlib.Path is provided, it is assumed to be the path to a schema file in json or yaml format.</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the schema is not valid</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def validate_schema(self, schema: str | Path | dict[str, Any]) -&gt; None:\n    \"\"\"Check if a schema is valid given the metadata schema\n\n    Args:\n        schema (str | Path | dict[str, Any]): Schema to check\n            If a string or pathlib.Path is provided, it is assumed to be the\n            path to a schema file in json or yaml format.\n\n    Raises:\n        jsonschema.exceptions.ValidationError: If the schema is not valid\n    \"\"\"\n    if isinstance(schema, str | Path):\n        schema = read_json_or_yaml(schema)\n    jsonschema.validate(instance=schema, schema=self._meta_schema)\n</code></pre>"},{"location":"api/api/#validators","title":"Validators","text":"<p>The TweakedValidator is a validator that serves test cases. It allows to specify the response of the validator for a given schema and data. In that it ensures that the schema is loaded but does not perform any validation. But returns the expected response. It also serves as a blue print for the implementation of the Validator class.</p> Source code in <code>sweet_validation/validator/tweaked_validator.py</code> <pre><code>class TweakedValidator:\n    \"\"\"The TweakedValidator is a validator that serves test cases. It allows\n    to specify the response of the validator for a given schema and data. In that\n    it ensures that the schema is loaded but does not perform any validation.\n    But returns the expected response. It also serves as a blue print for the\n    implementation of the Validator class.\n    \"\"\"\n\n    # TODO how to we implement validation reports?\n    def validate(\n        self, data: Any, schema: dict[str, Any], response: bool = True\n    ) -&gt; dict[str, Any]:\n        \"\"\"Validate the data against the schema\n\n        Args:\n            data (Any): Data to be validated\n            schema (dict[str, Any]): Schema to validate against\n            response (bool, optional): Expected response. Defaults to True.\n\n        Returns:\n            dict[str, Any]: Validation report\n        \"\"\"\n        return {\"valid\": response}\n\n    def is_valid(\n        self, data: Any, schema: dict[str, Any], response: bool = True\n    ) -&gt; bool:\n        \"\"\"Check if the data is valid against the schema\n\n        Args:\n            data (Any): Data to be validated\n            schema (dict[str, Any]): Schema to validate against\n            response (bool, optional): Expected response. Defaults to True.\n\n        Returns:\n            bool: True if valid else False\n        \"\"\"\n        if self.validate(data, schema, response=response)[\"valid\"]:\n            return True\n        return False\n</code></pre>"},{"location":"api/api/#sweet_validation.validator.tweaked_validator.TweakedValidator.is_valid","title":"<code>is_valid(data, schema, response=True)</code>","text":"<p>Check if the data is valid against the schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to be validated</p> required <code>schema</code> <code>dict[str, Any]</code> <p>Schema to validate against</p> required <code>response</code> <code>bool</code> <p>Expected response. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid else False</p> Source code in <code>sweet_validation/validator/tweaked_validator.py</code> <pre><code>def is_valid(\n    self, data: Any, schema: dict[str, Any], response: bool = True\n) -&gt; bool:\n    \"\"\"Check if the data is valid against the schema\n\n    Args:\n        data (Any): Data to be validated\n        schema (dict[str, Any]): Schema to validate against\n        response (bool, optional): Expected response. Defaults to True.\n\n    Returns:\n        bool: True if valid else False\n    \"\"\"\n    if self.validate(data, schema, response=response)[\"valid\"]:\n        return True\n    return False\n</code></pre>"},{"location":"api/api/#sweet_validation.validator.tweaked_validator.TweakedValidator.validate","title":"<code>validate(data, schema, response=True)</code>","text":"<p>Validate the data against the schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to be validated</p> required <code>schema</code> <code>dict[str, Any]</code> <p>Schema to validate against</p> required <code>response</code> <code>bool</code> <p>Expected response. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Validation report</p> Source code in <code>sweet_validation/validator/tweaked_validator.py</code> <pre><code>def validate(\n    self, data: Any, schema: dict[str, Any], response: bool = True\n) -&gt; dict[str, Any]:\n    \"\"\"Validate the data against the schema\n\n    Args:\n        data (Any): Data to be validated\n        schema (dict[str, Any]): Schema to validate against\n        response (bool, optional): Expected response. Defaults to True.\n\n    Returns:\n        dict[str, Any]: Validation report\n    \"\"\"\n    return {\"valid\": response}\n</code></pre>"},{"location":"api/api/#storage","title":"Storage","text":"<p>A storage backend that stores data in memory.</p> <p>This storage uses a dictionary to store data in memory given a key under which the data are stored.</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>class InMemoryStorage:\n    \"\"\"A storage backend that stores data in memory.\n\n    This storage uses a dictionary to store data in memory given a key under which\n    the data are stored.\n\n    \"\"\"\n\n    _data: dict[str, Any]\n\n    def __init__(self, data: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Initialize the storage backend\n\n        Args:\n            data (dict[str, Any], optional): A dictionary of data to initialize\n                the storage with. Defaults to None.\n        \"\"\"\n        super().__init__()\n        self._data = deepcopy(data) if data else {}\n\n    def save(self, key: str, value: Any) -&gt; None:\n        \"\"\"Save a value to the storage\n\n        Args:\n            key (str): The key of the value\n            value (Any): The value to save\n\n        Raises:\n            KeyError: If the key already exists\n        \"\"\"\n        if self.exists(key):\n            raise KeyError(f\"Key '{key}' already exists\")\n        self._data[key] = value\n\n    def load(self, key: str) -&gt; Any:\n        \"\"\"Load a value from the storage\n\n        Args:\n            key (str): The key of the value\n\n        Returns:\n            Any: The value stored at the key\n\n        Raises:\n            KeyError: If the key does not exist\n        \"\"\"\n        return self._data[key]\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Delete a value from the storage\n\n        Args:\n            key (str): The key of the value\n\n        Raises:\n            KeyError: If the key does not exist\n        \"\"\"\n        del self._data[key]\n\n    def exists(self, key: str) -&gt; bool:\n        \"\"\"Check if a value exists in the storage\n\n        Args:\n            key (str): The key of the value\n\n        Returns:\n            bool: True if the key exists, False otherwise\n        \"\"\"\n        return key in self._data\n\n    def list(self) -&gt; list[str]:\n        \"\"\"List all keys in the storage\n\n        Returns:\n            list[str]: A list of all keys in the storage\n        \"\"\"\n        return list(self._data.keys())\n\n    def replace(self, key: str, value: Any) -&gt; None:\n        \"\"\"Replace a value in the storage\n\n        Args:\n            key (str): The key of the value\n            value (Any): The new value\n\n        Raises:\n            KeyError: If the key does not exist\n        \"\"\"\n        self.delete(key)\n        self.save(key, value)\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.InMemoryStorage._data","title":"<code>_data = deepcopy(data) if data else {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/api/#sweet_validation.storage.InMemoryStorage.__init__","title":"<code>__init__(data=None)</code>","text":"<p>Initialize the storage backend</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary of data to initialize the storage with. Defaults to None.</p> <code>None</code> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def __init__(self, data: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Initialize the storage backend\n\n    Args:\n        data (dict[str, Any], optional): A dictionary of data to initialize\n            the storage with. Defaults to None.\n    \"\"\"\n    super().__init__()\n    self._data = deepcopy(data) if data else {}\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.InMemoryStorage.delete","title":"<code>delete(key)</code>","text":"<p>Delete a value from the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Delete a value from the storage\n\n    Args:\n        key (str): The key of the value\n\n    Raises:\n        KeyError: If the key does not exist\n    \"\"\"\n    del self._data[key]\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.InMemoryStorage.exists","title":"<code>exists(key)</code>","text":"<p>Check if a value exists in the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if a value exists in the storage\n\n    Args:\n        key (str): The key of the value\n\n    Returns:\n        bool: True if the key exists, False otherwise\n    \"\"\"\n    return key in self._data\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.InMemoryStorage.list","title":"<code>list()</code>","text":"<p>List all keys in the storage</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of all keys in the storage</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def list(self) -&gt; list[str]:\n    \"\"\"List all keys in the storage\n\n    Returns:\n        list[str]: A list of all keys in the storage\n    \"\"\"\n    return list(self._data.keys())\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.InMemoryStorage.load","title":"<code>load(key)</code>","text":"<p>Load a value from the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value stored at the key</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    \"\"\"Load a value from the storage\n\n    Args:\n        key (str): The key of the value\n\n    Returns:\n        Any: The value stored at the key\n\n    Raises:\n        KeyError: If the key does not exist\n    \"\"\"\n    return self._data[key]\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.InMemoryStorage.replace","title":"<code>replace(key, value)</code>","text":"<p>Replace a value in the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <code>value</code> <code>Any</code> <p>The new value</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def replace(self, key: str, value: Any) -&gt; None:\n    \"\"\"Replace a value in the storage\n\n    Args:\n        key (str): The key of the value\n        value (Any): The new value\n\n    Raises:\n        KeyError: If the key does not exist\n    \"\"\"\n    self.delete(key)\n    self.save(key, value)\n</code></pre>"},{"location":"api/api/#sweet_validation.storage.InMemoryStorage.save","title":"<code>save(key, value)</code>","text":"<p>Save a value to the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <code>value</code> <code>Any</code> <p>The value to save</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key already exists</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def save(self, key: str, value: Any) -&gt; None:\n    \"\"\"Save a value to the storage\n\n    Args:\n        key (str): The key of the value\n        value (Any): The value to save\n\n    Raises:\n        KeyError: If the key already exists\n    \"\"\"\n    if self.exists(key):\n        raise KeyError(f\"Key '{key}' already exists\")\n    self._data[key] = value\n</code></pre>"},{"location":"frictionless/frictionless/","title":"Frictionless Data","text":""},{"location":"frictionless/frictionless/#overview","title":"Overview","text":"<p>We use the Frictionless Data standard to describe data. In short the frictionless standard relies on to four main components:</p> <ol> <li>Table schema provides a section to describe a table, i.e., a meta-data section     and describes the table schema in terms of fields.</li> <li>Table dialect provides the possibility to describe the physical properties     of a table, i.e, how data are stored in a file.</li> <li>Data resource is the combination of a datafile and the respective descriptions     given in the form of table schemas and dialects.</li> <li>Data package allows to bundle several data resources.</li> </ol> <p>Our package relies on table schemas to describe data and we therefore explain their concept in greater detail.</p>"},{"location":"frictionless/frictionless/#table-schema","title":"Table Schema","text":"<p>A frictionless table schema is a json-schema specification to standardize the exchange of data. For all details take a look at the specification of the table schema. Our approach uses yaml files to describe data. Consider the following example of such a yaml:</p> <pre><code>name: generation\ntitle: Electricity generation\ndescription: &gt;\n    Electricity generation created by our awesome very unique electricity model\n    that is technically and economically very advanced. The table provides\n    annual generation by technology and year.\ncreated_by: User\ncreated_at: 2025-01-31\nfields:\n  - name: technology\n    type: string\n    constraint:\n        required: true\n        enum: [gas, coal, wind, solar]\n  - name: year\n    type: integer\n    constraint:\n        required: true\n        minimum: 2000\n        maximum: 2100\n  - name: value\n    type: number\n    constrain:\n        required: true\n</code></pre> <p>The table schema comes in two parts. The first part are the meta-data that describe the data and provides additional information, e.g., operational meta-data who created the data and at which date. The description of relational constrains including primary and foreign keys is also possible. It is possible to add any field you want to the meta-data section.</p> <p>The fields part describes the columns of the data. fields are by default the only part that is mandatory. A field has to have a name and should have at least a type, i.e, whether you are storing strings, numbers, integer, ... (see description of all possible types). Fields can be narrowed down using constraints: - required: Whether the field must be given - unique: Whether values in the field must be unique - minLength/maxLength: Allows to set the minimal and maximum value for collections (arrays, lists, strings) - maximum/minimum: Maximum/minimum for numerical values - pattern: Restrict strings by regular expressions - enum: Define a list of valid values for a string</p>"}]}