{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Sweet Validation","text":"<p>Sweet Validation is package to perform data validation within the Sweet CoSi project. To perform validation, the package relies on a description of data tables using yaml or json files. Data items are checked against the description provided in these files.</p>"},{"location":"#overview","title":"Overview","text":"<p>Our approach relies on a Registry that manages the schemas and its relations to data.</p> <p></p> <p>The registry relies on three main components:</p> <ul> <li>SchemaManager stores schemas that are used to validate data. The manager keeps track of the relation between schemas and data and also validates new schemas against the imposed meta-data standard.</li> <li>Validators provide methods to validate data against a given schema.</li> <li>FileStorage provides the methods to persist and retrieve data.</li> </ul> <p>Using validators, the registry coordinates the actions between the SchemaManager and the FileStorage ensuring that no data are saved or updated without validation.</p>"},{"location":"#installation","title":"Installation","text":"<p>tbd</p>"},{"location":"components/overview/","title":"Overview","text":"<p>Sweet-validations relies on a Registry that manages the schemas and its relations to data.</p> <p></p> <p>The registry relies on three main components:</p> <ul> <li>SchemaManager stores schemas that are used to validate data. The manager keeps track of the relation between schemas and data and also validates new schemas against the imposed meta-data standard.</li> <li>Validators provide methods to validate data against a given schema.</li> <li>FileStorage provides the methods to persist and retrieve data.</li> </ul> <p>Using validators, the registry coordinates the actions between the SchemaManager and the FileStorage ensuring that no data are saved or updated without validation.</p>"},{"location":"components/registries/","title":"Registry","text":""},{"location":"components/registries/#registries","title":"Registries","text":"<p>Registries coordinate actions between the data and schema storage. They ensure that no data are stored without a schema and that changes in data trigger a validation of data against the respective schema.</p>"},{"location":"components/registries/#api-docs","title":"API Docs","text":""},{"location":"components/registries/#in-memory-registry","title":"In Memory-Registry","text":"<p>The in-memory registry is the simplest registry possible. It uses the standard Sqlite-based SchemaManager together with an in-memory storage of the data. Therefore, data will be lost once you stop the Python program, i.e., data are not persisted.</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>class InMemoryRegistry:\n    _schema_manager: SchemaManager\n    _data_store: InMemoryStorage\n    _validator: ValidatorProtocol\n\n    def __init__(\n        self, validator: ValidatorProtocol, schema_manager: SchemaManager\n    ) -&gt; None:\n        \"\"\"Initialize the registry with schema manager and storage\n\n        Args:\n            validator (Any): Validator to validate data against schema\n        \"\"\"\n        self._schema_manager = schema_manager\n        self._validator = validator\n        self._data_store = InMemoryStorage()\n\n    # -------- schema related methods\n    def add_schema(self, key: str, schema: Any) -&gt; None:\n        \"\"\"Add schema to the registry. The schema is validated against the metadata\n        standard. If the schema already exists, a KeyError is raised.\n\n        Args:\n            key (str): Key of schema\n            schema (Any): Schema to be added\n\n        Raises:\n            KeyError: If the schema already exists\n        \"\"\"\n        self._schema_manager.add_schema(key=key, schema=schema)\n\n    def get_schema(self, key: str) -&gt; Any:\n        \"\"\"Given the key of schema, return the schema\n\n        Args:\n            key (str): Key of schema\n\n        Returns:\n            Any: Schema\n\n        Raises:\n            KeyError: If the schema does not exist\n        \"\"\"\n        return self._schema_manager[key]\n\n    def delete_schema(self, key: str) -&gt; None:\n        \"\"\"Given the key of schema delete it\n\n        Args:\n            key (str): Key of schema to delete\n\n        Raises:\n            ValueError: If the schema does not exist or data associated with\n                the schema still exist\n        \"\"\"\n        self._schema_manager.delete_schema(key=key)\n\n    def replace_schema(self, key: str, schema: Any) -&gt; None:\n        \"\"\"Replace a schema in the registry\n\n        Args:\n            key (str): Key of schema\n            schema (Any): New schema\n\n        Raises:\n            KeyError: If the schema does not exist\n            DataValidationError: If the data does not conform to the schema\n        \"\"\"\n        # ensure that new schema is valid\n        self._schema_manager.validate_schema(schema)\n        for data_key in self._schema_manager.list_data_for_schema(key):\n            data = self.get_data(data_key)\n            self._validate_data(data=data, schema=schema)\n        # replacement\n        self._schema_manager.replace_schema(key, schema)\n\n    @property\n    def schemas(self) -&gt; list[str]:\n        \"\"\"List all schemas\n\n        Returns:\n            list[str]: List of schema keys\n        \"\"\"\n        return self._schema_manager.schemas\n\n    # -------- data related methods\n    def add_data(self, key: str, schema_key: str, data: Any) -&gt; None:\n        \"\"\"Add data to the registry. The data is validated given the schema.\n\n        Args:\n            key (str): Key of data\n            schema_key (str): Key of schema\n            data (Any): Data to be added\n\n        Raises:\n            KeyError: If the schema does not exist\n        \"\"\"\n        if key in self._schema_manager.data:\n            raise KeyError(f\"Data {key} already exists\")\n        if schema_key not in self.schemas:\n            raise KeyError(f\"Schema {schema_key} does not exist\")\n        # validate data\n        self._validate_data(data=data, schema=self.get_schema(schema_key))\n        # add data\n        self._schema_manager.add_data(key=key, key_schema=schema_key)\n        self._data_store.save(key, data)\n\n    def get_data(self, key: str) -&gt; Any:\n        \"\"\"Given the key of data, return the data\n\n        Args:\n            key (str): Key of data\n\n        Returns:\n            Any: Data\n\n        Raises:\n            KeyError: If the data does not exist\n        \"\"\"\n        return self._data_store.load(key)\n\n    def delete_data(self, key: str) -&gt; None:\n        \"\"\"Given the key of data delete it\n\n        Args:\n            key (str): Key of data to delete\n\n        Raises:\n            IntegrityError: If the data does not exist\n        \"\"\"\n        self._schema_manager.delete_data(key=key)\n        self._data_store.delete(key)\n\n    def replace_data(self, key: str, data: Any) -&gt; None:\n        \"\"\"Replace a data in the registry\n\n        Args:\n            key (str): Key of data\n            data (Any): New data\n\n        Raises:\n            KeyError: If the data does not exist\n            ValidationError: If the data does not conform to the schema\n        \"\"\"\n        schema = self._schema_manager.get_data_schema(key)\n        # check data against schema\n        self._validate_data(data=data, schema=schema)\n        # replacement\n        self._data_store.replace(key, data)\n\n    def list_data(self) -&gt; list[tuple[str, str]]:\n        \"\"\"List all data\n\n        Returns:\n            list[tuple[str, str]]: List of data tuples (id, id_schema)\n\n        Raises:\n            IntegrityError: If the data does not exist\n        \"\"\"\n        return self._schema_manager.list_data()\n\n    def _validate_data(self, data: Any, schema: dict[str, Any]) -&gt; None:\n        \"\"\"Validate data against schema\n\n        Args:\n            data (Any): Data to be validated\n            schema (dict[str, Any]): Schema to validate against\n\n        Raises:\n            DataValidationError: If data does not conform to schema\n        \"\"\"\n        # check data against schema\n        if not self._validator.is_valid(data, schema):\n            raise DataValidationError(\"Data does not conform to schema\")\n\n    @property\n    def data(self) -&gt; list[str]:\n        \"\"\"List all data keys\n\n        Returns:\n            list[str]: List of data keys\n        \"\"\"\n        return self._schema_manager.data\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.data","title":"<code>data</code>  <code>property</code>","text":"<p>List all data keys</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of data keys</p>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.schemas","title":"<code>schemas</code>  <code>property</code>","text":"<p>List all schemas</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of schema keys</p>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.__init__","title":"<code>__init__(validator, schema_manager)</code>","text":"<p>Initialize the registry with schema manager and storage</p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>Any</code> <p>Validator to validate data against schema</p> required Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def __init__(\n    self, validator: ValidatorProtocol, schema_manager: SchemaManager\n) -&gt; None:\n    \"\"\"Initialize the registry with schema manager and storage\n\n    Args:\n        validator (Any): Validator to validate data against schema\n    \"\"\"\n    self._schema_manager = schema_manager\n    self._validator = validator\n    self._data_store = InMemoryStorage()\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry._validate_data","title":"<code>_validate_data(data, schema)</code>","text":"<p>Validate data against schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to be validated</p> required <code>schema</code> <code>dict[str, Any]</code> <p>Schema to validate against</p> required <p>Raises:</p> Type Description <code>DataValidationError</code> <p>If data does not conform to schema</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def _validate_data(self, data: Any, schema: dict[str, Any]) -&gt; None:\n    \"\"\"Validate data against schema\n\n    Args:\n        data (Any): Data to be validated\n        schema (dict[str, Any]): Schema to validate against\n\n    Raises:\n        DataValidationError: If data does not conform to schema\n    \"\"\"\n    # check data against schema\n    if not self._validator.is_valid(data, schema):\n        raise DataValidationError(\"Data does not conform to schema\")\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.add_data","title":"<code>add_data(key, schema_key, data)</code>","text":"<p>Add data to the registry. The data is validated given the schema.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data</p> required <code>schema_key</code> <code>str</code> <p>Key of schema</p> required <code>data</code> <code>Any</code> <p>Data to be added</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def add_data(self, key: str, schema_key: str, data: Any) -&gt; None:\n    \"\"\"Add data to the registry. The data is validated given the schema.\n\n    Args:\n        key (str): Key of data\n        schema_key (str): Key of schema\n        data (Any): Data to be added\n\n    Raises:\n        KeyError: If the schema does not exist\n    \"\"\"\n    if key in self._schema_manager.data:\n        raise KeyError(f\"Data {key} already exists\")\n    if schema_key not in self.schemas:\n        raise KeyError(f\"Schema {schema_key} does not exist\")\n    # validate data\n    self._validate_data(data=data, schema=self.get_schema(schema_key))\n    # add data\n    self._schema_manager.add_data(key=key, key_schema=schema_key)\n    self._data_store.save(key, data)\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.add_schema","title":"<code>add_schema(key, schema)</code>","text":"<p>Add schema to the registry. The schema is validated against the metadata standard. If the schema already exists, a KeyError is raised.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema</p> required <code>schema</code> <code>Any</code> <p>Schema to be added</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema already exists</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def add_schema(self, key: str, schema: Any) -&gt; None:\n    \"\"\"Add schema to the registry. The schema is validated against the metadata\n    standard. If the schema already exists, a KeyError is raised.\n\n    Args:\n        key (str): Key of schema\n        schema (Any): Schema to be added\n\n    Raises:\n        KeyError: If the schema already exists\n    \"\"\"\n    self._schema_manager.add_schema(key=key, schema=schema)\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.delete_data","title":"<code>delete_data(key)</code>","text":"<p>Given the key of data delete it</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data to delete</p> required <p>Raises:</p> Type Description <code>IntegrityError</code> <p>If the data does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def delete_data(self, key: str) -&gt; None:\n    \"\"\"Given the key of data delete it\n\n    Args:\n        key (str): Key of data to delete\n\n    Raises:\n        IntegrityError: If the data does not exist\n    \"\"\"\n    self._schema_manager.delete_data(key=key)\n    self._data_store.delete(key)\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.delete_schema","title":"<code>delete_schema(key)</code>","text":"<p>Given the key of schema delete it</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the schema does not exist or data associated with the schema still exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def delete_schema(self, key: str) -&gt; None:\n    \"\"\"Given the key of schema delete it\n\n    Args:\n        key (str): Key of schema to delete\n\n    Raises:\n        ValueError: If the schema does not exist or data associated with\n            the schema still exist\n    \"\"\"\n    self._schema_manager.delete_schema(key=key)\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.get_data","title":"<code>get_data(key)</code>","text":"<p>Given the key of data, return the data</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Data</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def get_data(self, key: str) -&gt; Any:\n    \"\"\"Given the key of data, return the data\n\n    Args:\n        key (str): Key of data\n\n    Returns:\n        Any: Data\n\n    Raises:\n        KeyError: If the data does not exist\n    \"\"\"\n    return self._data_store.load(key)\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.get_schema","title":"<code>get_schema(key)</code>","text":"<p>Given the key of schema, return the schema</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Schema</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def get_schema(self, key: str) -&gt; Any:\n    \"\"\"Given the key of schema, return the schema\n\n    Args:\n        key (str): Key of schema\n\n    Returns:\n        Any: Schema\n\n    Raises:\n        KeyError: If the schema does not exist\n    \"\"\"\n    return self._schema_manager[key]\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.list_data","title":"<code>list_data()</code>","text":"<p>List all data</p> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: List of data tuples (id, id_schema)</p> <p>Raises:</p> Type Description <code>IntegrityError</code> <p>If the data does not exist</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def list_data(self) -&gt; list[tuple[str, str]]:\n    \"\"\"List all data\n\n    Returns:\n        list[tuple[str, str]]: List of data tuples (id, id_schema)\n\n    Raises:\n        IntegrityError: If the data does not exist\n    \"\"\"\n    return self._schema_manager.list_data()\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.replace_data","title":"<code>replace_data(key, data)</code>","text":"<p>Replace a data in the registry</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of data</p> required <code>data</code> <code>Any</code> <p>New data</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data does not exist</p> <code>ValidationError</code> <p>If the data does not conform to the schema</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def replace_data(self, key: str, data: Any) -&gt; None:\n    \"\"\"Replace a data in the registry\n\n    Args:\n        key (str): Key of data\n        data (Any): New data\n\n    Raises:\n        KeyError: If the data does not exist\n        ValidationError: If the data does not conform to the schema\n    \"\"\"\n    schema = self._schema_manager.get_data_schema(key)\n    # check data against schema\n    self._validate_data(data=data, schema=schema)\n    # replacement\n    self._data_store.replace(key, data)\n</code></pre>"},{"location":"components/registries/#sweet_validation.registry.InMemoryRegistry.replace_schema","title":"<code>replace_schema(key, schema)</code>","text":"<p>Replace a schema in the registry</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of schema</p> required <code>schema</code> <code>Any</code> <p>New schema</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema does not exist</p> <code>DataValidationError</code> <p>If the data does not conform to the schema</p> Source code in <code>sweet_validation/registry/inmemory.py</code> <pre><code>def replace_schema(self, key: str, schema: Any) -&gt; None:\n    \"\"\"Replace a schema in the registry\n\n    Args:\n        key (str): Key of schema\n        schema (Any): New schema\n\n    Raises:\n        KeyError: If the schema does not exist\n        DataValidationError: If the data does not conform to the schema\n    \"\"\"\n    # ensure that new schema is valid\n    self._schema_manager.validate_schema(schema)\n    for data_key in self._schema_manager.list_data_for_schema(key):\n        data = self.get_data(data_key)\n        self._validate_data(data=data, schema=schema)\n    # replacement\n    self._schema_manager.replace_schema(key, schema)\n</code></pre>"},{"location":"components/schema_manager/","title":"SchemaManager","text":"<p>SchemaManagers manage your schemas. They perform the following tasks:</p> <ul> <li>Ensure that each provided schema complies with the metadata standard provided</li> <li>Allow to store and retrieve schemas</li> <li>Store the relations between data and schemas</li> </ul> <p>The default SchemaManager uses an Sqlite database to store schemas and relations.</p>"},{"location":"components/schema_manager/#metadata-standards","title":"Metadata Standards","text":"<p>The metadata standard is provided during the initialization of the SchemaManager. By default, the SchemaManager uses the frictionless table schema in version 1 with the additional constraint that name of the table is mandatory.</p> <p>The metadata standard can be changed in two different ways during initialization of the SchemaManager</p> <ol> <li>Provide your own metadata standard in the form of a json schema</li> <li>Extend the basic metadata standard providing additional json schemas. In that case, all schemas need to be fulfilled by newly created data schemas. TO BE IMPLEMENTED</li> </ol>"},{"location":"components/schema_manager/#api-docs","title":"API Docs","text":""},{"location":"components/schema_manager/#schemamanager_1","title":"SchemaManager","text":"<p>A simple relation manager based on SQLite</p> <p>The underlying database is in-memory if no filename is provided. If a filename is provided, the database is stored in the file. The database has two tables: Schema and Data. The schema table stores the schema key and the schema itself. The data table stores the data key and the schema key associated with the data. Note that data table does not store data but only the key to access the data.</p> <p>Attributes:</p> Name Type Description <code>schemas</code> <code>list[str]</code> <p>List of schema keys</p> <p>Methods:</p> Name Description <code>add_schema</code> <p>Insert a schema into the database</p> <code>delete_schema</code> <p>Delete a schema given the key</p> <code>replace_schema</code> <p>Replace a schema in the database</p> <code>list_data_for_schema</code> <p>Get the data keys associated with the schema key</p> <code>add_data</code> <p>Insert data into the database</p> <code>list_data</code> <p>Fetch all data keys</p> <code>delete_data</code> <p>Delete data given the key</p> <code>get_data_schema</code> <p>Get the schema key associated with the data key</p> <code>get_session</code> <p>Provides a context-managed database session</p> <code>close</code> <p>Close the database engine</p> <code>clear</code> <p>Clear all tables in the database</p> <code>clear_and_close</code> <p>Clear all data and close the database engine</p> <p>Example:</p> <pre><code>.. code-block:: python\n# create a schema manager based on the standard metadata schema\nmyManager = SchemaManager()\n\n# add a schema\nvalid_schema = {\n    \"fields\": [\n        {\"name\": \"id\", \"type\": \"integer\"},\n        {\"name\": \"name\", \"type\": \"string\"},\n    ],\n    \"name\": \"test\",\n}\nmyManager.add_schema(\"schema1\", valid_schema)\n# Likewise, if the schema is in a file, you can provide the path to the file\nmyManager.add_schema(\"schema2\", \"path/to/schema.yaml\")\n\n# the default schema is based on the frictionless table schema v1 with\n# the extension that the schema must have a name field\n# So the following schema is invalid\ninvalid_schema = {\n    \"fields\": [\n        {\"name\": \"id\", \"type\": \"integer\"},\n        {\"name\": \"name\", \"type\": \"string\"},\n    ],\n}\nmyManager.add_schema(\"schema2\", invalid_schema) # ==&gt; raises jsonschema.exceptions.ValidationError\n</code></pre> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>class SchemaManager:\n    \"\"\"A simple relation manager based on SQLite\n\n    The underlying database is in-memory if no filename is provided.\n    If a filename is provided, the database is stored in the file.\n    The database has two tables: Schema and Data. The schema table stores the\n    schema key and the schema itself. The data table stores the data key and the\n    schema key associated with the data. Note that data table does not store data\n    but only the key to access the data.\n\n    Attributes:\n        schemas: List of schema keys\n\n    Methods:\n        # schema management methods\n        add_schema: Insert a schema into the database\n        delete_schema: Delete a schema given the key\n        replace_schema: Replace a schema in the database\n        list_data_for_schema: Get the data keys associated with the schema key\n\n        # data management methods\n        add_data: Insert data into the database\n        list_data: Fetch all data keys\n        delete_data: Delete data given the key\n        get_data_schema: Get the schema key associated with the data key\n\n        # db management methods\n        get_session: Provides a context-managed database session\n        close: Close the database engine\n        clear: Clear all tables in the database\n        clear_and_close: Clear all data and close the database engine\n\n    Example:\n\n        .. code-block:: python\n        # create a schema manager based on the standard metadata schema\n        myManager = SchemaManager()\n\n        # add a schema\n        valid_schema = {\n            \"fields\": [\n                {\"name\": \"id\", \"type\": \"integer\"},\n                {\"name\": \"name\", \"type\": \"string\"},\n            ],\n            \"name\": \"test\",\n        }\n        myManager.add_schema(\"schema1\", valid_schema)\n        # Likewise, if the schema is in a file, you can provide the path to the file\n        myManager.add_schema(\"schema2\", \"path/to/schema.yaml\")\n\n        # the default schema is based on the frictionless table schema v1 with\n        # the extension that the schema must have a name field\n        # So the following schema is invalid\n        invalid_schema = {\n            \"fields\": [\n                {\"name\": \"id\", \"type\": \"integer\"},\n                {\"name\": \"name\", \"type\": \"string\"},\n            ],\n        }\n        myManager.add_schema(\"schema2\", invalid_schema) # ==&gt; raises jsonschema.exceptions.ValidationError\n    \"\"\"  # noqa: E501\n\n    key_meta_schema = \"__meta_schema__\"\n\n    def __init__(\n        self,\n        fn_db: str | None = None,\n        meta_schema: str | Path | dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the database engine and session factory\n        Args:\n            fn (str | None): Filename of the sqlite database\n                Defaults to None, which uses an in-memory database\n            meta_schema (str | Schema | None): Metadata schema for the database\n                Defaults to None, which uses the default schema. If a string is\n                provided it is assumed to be a path to a schema file in yaml format.\n        \"\"\"\n        # create the meta-data schema\n        # TODO allow for extensions of the base schema\n        meta_schema = meta_schema or BASE_SCHEMA\n        self._meta_schema: dict[str, Any] = read_schema_from_file(meta_schema)\n\n        # self._meta_schema = self._create_schema_from_file(meta_schema)\n        # create the engine and the tables\n        conn_str = f\"sqlite:///{fn_db}\" if fn_db else \"sqlite:///:memory:\"\n        self._init_db(conn_str)\n\n        # check whether the meta-schema is in the database else create it\n        try:\n            self._meta_schema = self[self.key_meta_schema]\n        except KeyError:\n            self._write_schema_to_db(self.key_meta_schema, self._meta_schema)\n\n    def _create_and_check_schema(\n        self, schema: str | Path | dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a schema from file and return the scheme itself it is already a\n        schema\n\n        Args:\n            schema (str | Path | dict[str, Any]): Schema\n                If a string or pathlib.Path is provided, it is assumed to be the\n                path to a schema file in json or yaml format\n\n        Returns:\n            dict[str, Any]: Schema\n        \"\"\"\n        schema = read_schema_from_file(schema)\n        self.validate_schema(schema)\n        return schema\n\n    # --------- schema management methods\n    @property\n    def schemas(self) -&gt; list[str]:\n        \"\"\"Fetch all schema keys\n\n        Returns:\n            list[str]: List of schema keys\n        \"\"\"\n        with self.get_session() as session:\n            return [\n                schema.id\n                for schema in session.query(SchemaTable).all()\n                if schema.id != self.key_meta_schema\n            ]\n\n    def __getitem__(self, key: str) -&gt; dict[str, Any]:\n        \"\"\"Get the schema given the key\n\n        Args:\n            key (str): Schema key\n\n        Raises:\n            KeyError: If the schema key does not exist\n\n        Returns:\n            str: Schema\n        \"\"\"\n        with self.get_session() as session:\n            schema = session.query(SchemaTable).filter(SchemaTable.id == key).first()\n            if not schema:\n                raise KeyError(f\"Schema key '{key}' not found\")\n            return cast(dict[str, Any], json.loads(schema.schema))\n\n    def add_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n        \"\"\"Insert a schema into the database given the key\n\n        Args:\n            key (str): Schema key\n            schema (str | Path | dict[str, Any]): Schema\n                If a string or pathlib.Path is provided, it is assumed to be the\n                path to a schema file in json or yaml format.\n\n        Raises:\n            KeyError: If the schema key already exists\n        \"\"\"\n        if key in self.schemas:\n            raise KeyError(f\"Schema key '{key}' already exists\")\n\n        schema = self._create_and_check_schema(schema)\n\n        # convert schema to json string and store in database\n        self._write_schema_to_db(key, schema)\n\n    def delete_schema(self, key: str) -&gt; None:\n        \"\"\"Delete a schema given the key\n\n        Args:\n            key (str): Schema key\n\n        Raises:\n            KeyError: If schema does not exist\n            ValueError: If some data is still associated with the schema\n        \"\"\"\n        if key not in self.schemas:\n            raise KeyError(f\"Schema key '{key}' not found\")\n        if self.list_data_for_schema(key):\n            raise ValueError(f\"Data associated with schema key '{key}' still exists\")\n        with self.get_session() as session:\n            session.query(SchemaTable).filter(SchemaTable.id == key).delete()\n            session.commit()\n\n    def replace_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n        \"\"\"Replace a schema in the database\n\n        Args:\n            key (str): Schema key\n            schema (str | Schema): New schema\n\n        Raises:\n            KeyError: If the schema key does not exist\n        \"\"\"\n        if key not in self.schemas:\n            raise KeyError(f\"Schema key '{key}' not found\")\n\n        schema = self._create_and_check_schema(schema)\n\n        schema = json.dumps(schema)\n        with self.get_session() as session:\n            session.query(SchemaTable).filter(SchemaTable.id == key).update(\n                {\"schema\": schema}\n            )\n            session.commit()\n\n    def list_data_for_schema(self, key: str) -&gt; list[str]:\n        \"\"\"Get the data keys associated with the schema key\n\n        Args:\n            key (str): Schema key\n\n        Returns:\n            list[str]: List of data keys\n        \"\"\"\n        with self.get_session() as session:\n            data = session.query(DataTable).filter(DataTable.id_schema == key).all()\n            return [str(d.id) for d in data]\n\n    def validate_schema(self, schema: str | Path | dict[str, Any]) -&gt; None:\n        \"\"\"Check if a schema is valid given the metadata schema\n\n        Args:\n            schema (str | Path | dict[str, Any]): Schema to check\n                If a string or pathlib.Path is provided, it is assumed to be the\n                path to a schema file in json or yaml format.\n\n        Raises:\n            jsonschema.exceptions.ValidationError: If the schema is not valid\n        \"\"\"\n        if isinstance(schema, str | Path):\n            schema = read_schema_from_file(schema)\n        jsonschema.validate(instance=schema, schema=self._meta_schema)\n\n    def _write_schema_to_db(self, key: str, schema: dict[str, Any]) -&gt; None:\n        \"\"\"Write a schema to the database\n\n        Args:\n            key (str): Schema key\n            schema (dict[str, Any]): Schema\n        \"\"\"\n        my_schema = json.dumps(schema)\n        with self.get_session() as session:\n            session.add(SchemaTable(id=key, schema=my_schema))\n            session.commit()\n\n    # --------- data management methods\n    @property\n    def data(self) -&gt; list[str]:\n        \"\"\"List of all data keys\n\n        Returns:\n            list[str]: List of data keys\n        \"\"\"\n        return [d[0] for d in self.list_data()]\n\n    def add_data(self, key: str, key_schema: str) -&gt; None:\n        \"\"\"Insert data into the database given the key and key of associated schema\n\n        Args:\n            key (str): Data key\n            key_schema (str): Schema key\n\n        Raises:\n            KeyError: If the primary key or foreign constraint is violated\n        \"\"\"\n        if key in self.data:\n            raise KeyError(f\"Data key '{key}' already exists\")\n        if key_schema not in self.schemas:\n            raise KeyError(f\"Schema key '{key_schema}' not found\")\n        with self.get_session() as session:\n            session.add(DataTable(id=key, id_schema=key_schema))\n            session.commit()\n\n    def list_data(self) -&gt; list[tuple[str, str]]:\n        \"\"\"Fetch all data\n\n        Returns:\n            list[tuple[str, str]]: List of data tuples (id, id_schema)\n        \"\"\"\n        with self.get_session() as session:\n            return [\n                (data.id, data.id_schema) for data in session.query(DataTable).all()\n            ]\n\n    def delete_data(self, key: str) -&gt; None:\n        \"\"\"Delete data given the key\n\n        Args:\n            key (str): Data key\n\n        Raises:\n            KeyError: If the data key does not exist\n        \"\"\"\n        if key not in [d[0] for d in self.list_data()]:\n            raise KeyError(f\"Data key '{key}' not found\")\n        with self.get_session() as session:\n            session.query(DataTable).filter(DataTable.id == key).delete()\n            session.commit()\n\n    def get_data_schema(self, key: str) -&gt; dict[str, Any]:\n        \"\"\"Get the schema key associated with the data key\n\n        Args:\n            key (str): Data key\n\n        raises:\n            KeyError: If the data key does not exist\n\n        Returns:\n            str: Schema\n        \"\"\"\n        key_schema = self.get_data_schema_key(key)\n        return self[key_schema]\n\n    def get_data_schema_key(self, key: str) -&gt; str:\n        \"\"\"Get the schema key associated with the data key\n\n        Args:\n            key (str): Data key\n\n        raises:\n            KeyError: If the data key does not exist\n\n        Returns:\n            str: Schema key\n        \"\"\"\n        with self.get_session() as session:\n            data = session.query(DataTable).filter(DataTable.id == key).first()\n            if not data:\n                raise KeyError(f\"Data key '{key}' not found\")\n            return str(data.id_schema)\n\n    # --------- db management methods\n    def _init_db(self, conn_str: str) -&gt; None:\n        \"\"\"Initialize the database with the metadata schema\n\n        Args:\n            conn_str (str): Connection string to the database\n        \"\"\"\n        self._conn_str = conn_str\n        self._engine = create_engine(self._conn_str)\n        Base.metadata.create_all(self._engine)  # Create tables if they don't exist\n        self._SessionLocal = sessionmaker(bind=self._engine)  # Create session factory\n\n    def _close_engine(self) -&gt; None:\n        \"\"\"Close the database engine.\"\"\"\n        self._engine.dispose()\n        self._engine = None\n\n    def close(self) -&gt; None:\n        \"\"\"Close the database engine.\"\"\"\n        self._close_engine()\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all data in the database\"\"\"\n        with self.get_session() as session:\n            session.query(DataTable).delete()\n            session.query(SchemaTable).delete()\n            session.commit()\n\n    def clear_and_close(self) -&gt; None:\n        \"\"\"Clear all data in the database and close the engine\"\"\"\n        self.clear()\n        self.close()\n\n    @contextmanager\n    def get_session(self) -&gt; Generator[Session, None, None]:\n        \"\"\"Provides a context-managed database session.\"\"\"\n        session = self._SessionLocal()\n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            session.rollback()\n            raise e  # Re-raise after rollback\n        finally:\n            session.close()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.data","title":"<code>data</code>  <code>property</code>","text":"<p>List of all data keys</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of data keys</p>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.schemas","title":"<code>schemas</code>  <code>property</code>","text":"<p>Fetch all schema keys</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of schema keys</p>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the schema given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema key does not exist</p> <p>Returns:</p> Name Type Description <code>str</code> <code>dict[str, Any]</code> <p>Schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def __getitem__(self, key: str) -&gt; dict[str, Any]:\n    \"\"\"Get the schema given the key\n\n    Args:\n        key (str): Schema key\n\n    Raises:\n        KeyError: If the schema key does not exist\n\n    Returns:\n        str: Schema\n    \"\"\"\n    with self.get_session() as session:\n        schema = session.query(SchemaTable).filter(SchemaTable.id == key).first()\n        if not schema:\n            raise KeyError(f\"Schema key '{key}' not found\")\n        return cast(dict[str, Any], json.loads(schema.schema))\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.__init__","title":"<code>__init__(fn_db=None, meta_schema=None)</code>","text":"<p>Initialize the database engine and session factory Args:     fn (str | None): Filename of the sqlite database         Defaults to None, which uses an in-memory database     meta_schema (str | Schema | None): Metadata schema for the database         Defaults to None, which uses the default schema. If a string is         provided it is assumed to be a path to a schema file in yaml format.</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def __init__(\n    self,\n    fn_db: str | None = None,\n    meta_schema: str | Path | dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the database engine and session factory\n    Args:\n        fn (str | None): Filename of the sqlite database\n            Defaults to None, which uses an in-memory database\n        meta_schema (str | Schema | None): Metadata schema for the database\n            Defaults to None, which uses the default schema. If a string is\n            provided it is assumed to be a path to a schema file in yaml format.\n    \"\"\"\n    # create the meta-data schema\n    # TODO allow for extensions of the base schema\n    meta_schema = meta_schema or BASE_SCHEMA\n    self._meta_schema: dict[str, Any] = read_schema_from_file(meta_schema)\n\n    # self._meta_schema = self._create_schema_from_file(meta_schema)\n    # create the engine and the tables\n    conn_str = f\"sqlite:///{fn_db}\" if fn_db else \"sqlite:///:memory:\"\n    self._init_db(conn_str)\n\n    # check whether the meta-schema is in the database else create it\n    try:\n        self._meta_schema = self[self.key_meta_schema]\n    except KeyError:\n        self._write_schema_to_db(self.key_meta_schema, self._meta_schema)\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager._close_engine","title":"<code>_close_engine()</code>","text":"<p>Close the database engine.</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def _close_engine(self) -&gt; None:\n    \"\"\"Close the database engine.\"\"\"\n    self._engine.dispose()\n    self._engine = None\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager._create_and_check_schema","title":"<code>_create_and_check_schema(schema)</code>","text":"<p>Create a schema from file and return the scheme itself it is already a schema</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str | Path | dict[str, Any]</code> <p>Schema If a string or pathlib.Path is provided, it is assumed to be the path to a schema file in json or yaml format</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def _create_and_check_schema(\n    self, schema: str | Path | dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Create a schema from file and return the scheme itself it is already a\n    schema\n\n    Args:\n        schema (str | Path | dict[str, Any]): Schema\n            If a string or pathlib.Path is provided, it is assumed to be the\n            path to a schema file in json or yaml format\n\n    Returns:\n        dict[str, Any]: Schema\n    \"\"\"\n    schema = read_schema_from_file(schema)\n    self.validate_schema(schema)\n    return schema\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager._init_db","title":"<code>_init_db(conn_str)</code>","text":"<p>Initialize the database with the metadata schema</p> <p>Parameters:</p> Name Type Description Default <code>conn_str</code> <code>str</code> <p>Connection string to the database</p> required Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def _init_db(self, conn_str: str) -&gt; None:\n    \"\"\"Initialize the database with the metadata schema\n\n    Args:\n        conn_str (str): Connection string to the database\n    \"\"\"\n    self._conn_str = conn_str\n    self._engine = create_engine(self._conn_str)\n    Base.metadata.create_all(self._engine)  # Create tables if they don't exist\n    self._SessionLocal = sessionmaker(bind=self._engine)  # Create session factory\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager._write_schema_to_db","title":"<code>_write_schema_to_db(key, schema)</code>","text":"<p>Write a schema to the database</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <code>schema</code> <code>dict[str, Any]</code> <p>Schema</p> required Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def _write_schema_to_db(self, key: str, schema: dict[str, Any]) -&gt; None:\n    \"\"\"Write a schema to the database\n\n    Args:\n        key (str): Schema key\n        schema (dict[str, Any]): Schema\n    \"\"\"\n    my_schema = json.dumps(schema)\n    with self.get_session() as session:\n        session.add(SchemaTable(id=key, schema=my_schema))\n        session.commit()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.add_data","title":"<code>add_data(key, key_schema)</code>","text":"<p>Insert data into the database given the key and key of associated schema</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <code>key_schema</code> <code>str</code> <p>Schema key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the primary key or foreign constraint is violated</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def add_data(self, key: str, key_schema: str) -&gt; None:\n    \"\"\"Insert data into the database given the key and key of associated schema\n\n    Args:\n        key (str): Data key\n        key_schema (str): Schema key\n\n    Raises:\n        KeyError: If the primary key or foreign constraint is violated\n    \"\"\"\n    if key in self.data:\n        raise KeyError(f\"Data key '{key}' already exists\")\n    if key_schema not in self.schemas:\n        raise KeyError(f\"Schema key '{key_schema}' not found\")\n    with self.get_session() as session:\n        session.add(DataTable(id=key, id_schema=key_schema))\n        session.commit()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.add_schema","title":"<code>add_schema(key, schema)</code>","text":"<p>Insert a schema into the database given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <code>schema</code> <code>str | Path | dict[str, Any]</code> <p>Schema If a string or pathlib.Path is provided, it is assumed to be the path to a schema file in json or yaml format.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema key already exists</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def add_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n    \"\"\"Insert a schema into the database given the key\n\n    Args:\n        key (str): Schema key\n        schema (str | Path | dict[str, Any]): Schema\n            If a string or pathlib.Path is provided, it is assumed to be the\n            path to a schema file in json or yaml format.\n\n    Raises:\n        KeyError: If the schema key already exists\n    \"\"\"\n    if key in self.schemas:\n        raise KeyError(f\"Schema key '{key}' already exists\")\n\n    schema = self._create_and_check_schema(schema)\n\n    # convert schema to json string and store in database\n    self._write_schema_to_db(key, schema)\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.clear","title":"<code>clear()</code>","text":"<p>Clear all data in the database</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all data in the database\"\"\"\n    with self.get_session() as session:\n        session.query(DataTable).delete()\n        session.query(SchemaTable).delete()\n        session.commit()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.clear_and_close","title":"<code>clear_and_close()</code>","text":"<p>Clear all data in the database and close the engine</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def clear_and_close(self) -&gt; None:\n    \"\"\"Clear all data in the database and close the engine\"\"\"\n    self.clear()\n    self.close()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.close","title":"<code>close()</code>","text":"<p>Close the database engine.</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the database engine.\"\"\"\n    self._close_engine()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.delete_data","title":"<code>delete_data(key)</code>","text":"<p>Delete data given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data key does not exist</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def delete_data(self, key: str) -&gt; None:\n    \"\"\"Delete data given the key\n\n    Args:\n        key (str): Data key\n\n    Raises:\n        KeyError: If the data key does not exist\n    \"\"\"\n    if key not in [d[0] for d in self.list_data()]:\n        raise KeyError(f\"Data key '{key}' not found\")\n    with self.get_session() as session:\n        session.query(DataTable).filter(DataTable.id == key).delete()\n        session.commit()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.delete_schema","title":"<code>delete_schema(key)</code>","text":"<p>Delete a schema given the key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If schema does not exist</p> <code>ValueError</code> <p>If some data is still associated with the schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def delete_schema(self, key: str) -&gt; None:\n    \"\"\"Delete a schema given the key\n\n    Args:\n        key (str): Schema key\n\n    Raises:\n        KeyError: If schema does not exist\n        ValueError: If some data is still associated with the schema\n    \"\"\"\n    if key not in self.schemas:\n        raise KeyError(f\"Schema key '{key}' not found\")\n    if self.list_data_for_schema(key):\n        raise ValueError(f\"Data associated with schema key '{key}' still exists\")\n    with self.get_session() as session:\n        session.query(SchemaTable).filter(SchemaTable.id == key).delete()\n        session.commit()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.get_data_schema","title":"<code>get_data_schema(key)</code>","text":"<p>Get the schema key associated with the data key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data key does not exist</p> <p>Returns:</p> Name Type Description <code>str</code> <code>dict[str, Any]</code> <p>Schema</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def get_data_schema(self, key: str) -&gt; dict[str, Any]:\n    \"\"\"Get the schema key associated with the data key\n\n    Args:\n        key (str): Data key\n\n    raises:\n        KeyError: If the data key does not exist\n\n    Returns:\n        str: Schema\n    \"\"\"\n    key_schema = self.get_data_schema_key(key)\n    return self[key_schema]\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.get_data_schema_key","title":"<code>get_data_schema_key(key)</code>","text":"<p>Get the schema key associated with the data key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Data key</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the data key does not exist</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Schema key</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def get_data_schema_key(self, key: str) -&gt; str:\n    \"\"\"Get the schema key associated with the data key\n\n    Args:\n        key (str): Data key\n\n    raises:\n        KeyError: If the data key does not exist\n\n    Returns:\n        str: Schema key\n    \"\"\"\n    with self.get_session() as session:\n        data = session.query(DataTable).filter(DataTable.id == key).first()\n        if not data:\n            raise KeyError(f\"Data key '{key}' not found\")\n        return str(data.id_schema)\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.get_session","title":"<code>get_session()</code>","text":"<p>Provides a context-managed database session.</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>@contextmanager\ndef get_session(self) -&gt; Generator[Session, None, None]:\n    \"\"\"Provides a context-managed database session.\"\"\"\n    session = self._SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e  # Re-raise after rollback\n    finally:\n        session.close()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.list_data","title":"<code>list_data()</code>","text":"<p>Fetch all data</p> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list[tuple[str, str]]: List of data tuples (id, id_schema)</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def list_data(self) -&gt; list[tuple[str, str]]:\n    \"\"\"Fetch all data\n\n    Returns:\n        list[tuple[str, str]]: List of data tuples (id, id_schema)\n    \"\"\"\n    with self.get_session() as session:\n        return [\n            (data.id, data.id_schema) for data in session.query(DataTable).all()\n        ]\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.list_data_for_schema","title":"<code>list_data_for_schema(key)</code>","text":"<p>Get the data keys associated with the schema key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of data keys</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def list_data_for_schema(self, key: str) -&gt; list[str]:\n    \"\"\"Get the data keys associated with the schema key\n\n    Args:\n        key (str): Schema key\n\n    Returns:\n        list[str]: List of data keys\n    \"\"\"\n    with self.get_session() as session:\n        data = session.query(DataTable).filter(DataTable.id_schema == key).all()\n        return [str(d.id) for d in data]\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.replace_schema","title":"<code>replace_schema(key, schema)</code>","text":"<p>Replace a schema in the database</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Schema key</p> required <code>schema</code> <code>str | Schema</code> <p>New schema</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the schema key does not exist</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def replace_schema(self, key: str, schema: str | Path | dict[str, Any]) -&gt; None:\n    \"\"\"Replace a schema in the database\n\n    Args:\n        key (str): Schema key\n        schema (str | Schema): New schema\n\n    Raises:\n        KeyError: If the schema key does not exist\n    \"\"\"\n    if key not in self.schemas:\n        raise KeyError(f\"Schema key '{key}' not found\")\n\n    schema = self._create_and_check_schema(schema)\n\n    schema = json.dumps(schema)\n    with self.get_session() as session:\n        session.query(SchemaTable).filter(SchemaTable.id == key).update(\n            {\"schema\": schema}\n        )\n        session.commit()\n</code></pre>"},{"location":"components/schema_manager/#sweet_validation.schema_manager.SchemaManager.validate_schema","title":"<code>validate_schema(schema)</code>","text":"<p>Check if a schema is valid given the metadata schema</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str | Path | dict[str, Any]</code> <p>Schema to check If a string or pathlib.Path is provided, it is assumed to be the path to a schema file in json or yaml format.</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the schema is not valid</p> Source code in <code>sweet_validation/schema_manager/schema_manager.py</code> <pre><code>def validate_schema(self, schema: str | Path | dict[str, Any]) -&gt; None:\n    \"\"\"Check if a schema is valid given the metadata schema\n\n    Args:\n        schema (str | Path | dict[str, Any]): Schema to check\n            If a string or pathlib.Path is provided, it is assumed to be the\n            path to a schema file in json or yaml format.\n\n    Raises:\n        jsonschema.exceptions.ValidationError: If the schema is not valid\n    \"\"\"\n    if isinstance(schema, str | Path):\n        schema = read_schema_from_file(schema)\n    jsonschema.validate(instance=schema, schema=self._meta_schema)\n</code></pre>"},{"location":"components/storage/","title":"Storage","text":""},{"location":"components/storage/#storage","title":"Storage","text":"<p>Storage is responsible to store received data. It is characterized by a simple Protocol that allows to store, retrieve, and replace data.</p>"},{"location":"components/storage/#api-docs","title":"API Docs","text":""},{"location":"components/storage/#storage-protocol","title":"Storage Protocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for storage backends</p> <p>Storage backends implement at the very least the following methods:</p> <p>Methods:</p> Name Description <code>save</code> <p>Save a value to the storage backend.</p> <code>load</code> <p>Load a value from the storage backend.</p> <code>delete</code> <p>Delete a value from the storage backend.</p> <code>exists</code> <p>Check if a value exists in the storage backend.</p> <code>list</code> <p>List all keys in the storage backend.</p> <code>replace</code> <p>Replace a value in the storage backend. This method is already implemented and calls delete and save.</p> Source code in <code>sweet_validation/protocols/protocols.py</code> <pre><code>@runtime_checkable\nclass StorageProtocol(Protocol):\n    \"\"\"Protocol for storage backends\n\n    Storage backends implement at the very least the following methods:\n\n    Methods:\n        save: Save a value to the storage backend.\n        load: Load a value from the storage backend.\n        delete: Delete a value from the storage backend.\n        exists: Check if a value exists in the storage backend.\n        list: List all keys in the storage backend.\n        replace: Replace a value in the storage backend.\n            This method is already implemented and calls delete and save.\n    \"\"\"\n\n    def save(self, key: Any, value: Any, **kwargs: Any) -&gt; None: ...\n    def load(self, key: Any, **kwargs: Any) -&gt; Any: ...\n    def delete(self, key: Any, **kwargs: Any) -&gt; Any: ...\n    def exists(self, key: Any, **kwargs: Any) -&gt; bool: ...\n    def list(self) -&gt; list[Any]: ...\n    def replace(self, key: Any, value: Any, **kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"components/storage/#inmemorystorage","title":"InMemoryStorage","text":"<p>The InMemoryStorage class is a simple storage that uses a dictionary to store your data. As data are not persisted, its main use case is testing.</p> <p>A storage backend that stores data in memory.</p> <p>This storage uses a dictionary to store data in memory given a key under which the data are stored.</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>class InMemoryStorage:\n    \"\"\"A storage backend that stores data in memory.\n\n    This storage uses a dictionary to store data in memory given a key under which\n    the data are stored.\n\n    \"\"\"\n\n    _data: dict[str, Any]\n\n    def __init__(self, data: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Initialize the storage backend\n\n        Args:\n            data (dict[str, Any], optional): A dictionary of data to initialize\n                the storage with. Defaults to None.\n        \"\"\"\n        super().__init__()\n        self._data = deepcopy(data) if data else {}\n\n    def save(self, key: str, value: Any) -&gt; None:\n        \"\"\"Save a value to the storage\n\n        Args:\n            key (str): The key of the value\n            value (Any): The value to save\n\n        Raises:\n            KeyError: If the key already exists\n        \"\"\"\n        if self.exists(key):\n            raise KeyError(f\"Key '{key}' already exists\")\n        self._data[key] = value\n\n    def load(self, key: str) -&gt; Any:\n        \"\"\"Load a value from the storage\n\n        Args:\n            key (str): The key of the value\n\n        Returns:\n            Any: The value stored at the key\n\n        Raises:\n            KeyError: If the key does not exist\n        \"\"\"\n        return self._data[key]\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Delete a value from the storage\n\n        Args:\n            key (str): The key of the value\n\n        Raises:\n            KeyError: If the key does not exist\n        \"\"\"\n        del self._data[key]\n\n    def exists(self, key: str) -&gt; bool:\n        \"\"\"Check if a value exists in the storage\n\n        Args:\n            key (str): The key of the value\n\n        Returns:\n            bool: True if the key exists, False otherwise\n        \"\"\"\n        return key in self._data\n\n    def list(self) -&gt; list[str]:\n        \"\"\"List all keys in the storage\n\n        Returns:\n            list[str]: A list of all keys in the storage\n        \"\"\"\n        return list(self._data.keys())\n\n    def replace(self, key: str, value: Any) -&gt; None:\n        \"\"\"Replace a value in the storage\n\n        Args:\n            key (str): The key of the value\n            value (Any): The new value\n\n        Raises:\n            KeyError: If the key does not exist\n        \"\"\"\n        self.delete(key)\n        self.save(key, value)\n</code></pre>"},{"location":"components/storage/#sweet_validation.storage.InMemoryStorage.__init__","title":"<code>__init__(data=None)</code>","text":"<p>Initialize the storage backend</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary of data to initialize the storage with. Defaults to None.</p> <code>None</code> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def __init__(self, data: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Initialize the storage backend\n\n    Args:\n        data (dict[str, Any], optional): A dictionary of data to initialize\n            the storage with. Defaults to None.\n    \"\"\"\n    super().__init__()\n    self._data = deepcopy(data) if data else {}\n</code></pre>"},{"location":"components/storage/#sweet_validation.storage.InMemoryStorage.delete","title":"<code>delete(key)</code>","text":"<p>Delete a value from the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Delete a value from the storage\n\n    Args:\n        key (str): The key of the value\n\n    Raises:\n        KeyError: If the key does not exist\n    \"\"\"\n    del self._data[key]\n</code></pre>"},{"location":"components/storage/#sweet_validation.storage.InMemoryStorage.exists","title":"<code>exists(key)</code>","text":"<p>Check if a value exists in the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if a value exists in the storage\n\n    Args:\n        key (str): The key of the value\n\n    Returns:\n        bool: True if the key exists, False otherwise\n    \"\"\"\n    return key in self._data\n</code></pre>"},{"location":"components/storage/#sweet_validation.storage.InMemoryStorage.list","title":"<code>list()</code>","text":"<p>List all keys in the storage</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of all keys in the storage</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def list(self) -&gt; list[str]:\n    \"\"\"List all keys in the storage\n\n    Returns:\n        list[str]: A list of all keys in the storage\n    \"\"\"\n    return list(self._data.keys())\n</code></pre>"},{"location":"components/storage/#sweet_validation.storage.InMemoryStorage.load","title":"<code>load(key)</code>","text":"<p>Load a value from the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value stored at the key</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def load(self, key: str) -&gt; Any:\n    \"\"\"Load a value from the storage\n\n    Args:\n        key (str): The key of the value\n\n    Returns:\n        Any: The value stored at the key\n\n    Raises:\n        KeyError: If the key does not exist\n    \"\"\"\n    return self._data[key]\n</code></pre>"},{"location":"components/storage/#sweet_validation.storage.InMemoryStorage.replace","title":"<code>replace(key, value)</code>","text":"<p>Replace a value in the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <code>value</code> <code>Any</code> <p>The new value</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def replace(self, key: str, value: Any) -&gt; None:\n    \"\"\"Replace a value in the storage\n\n    Args:\n        key (str): The key of the value\n        value (Any): The new value\n\n    Raises:\n        KeyError: If the key does not exist\n    \"\"\"\n    self.delete(key)\n    self.save(key, value)\n</code></pre>"},{"location":"components/storage/#sweet_validation.storage.InMemoryStorage.save","title":"<code>save(key, value)</code>","text":"<p>Save a value to the storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the value</p> required <code>value</code> <code>Any</code> <p>The value to save</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key already exists</p> Source code in <code>sweet_validation/storage/inmemory.py</code> <pre><code>def save(self, key: str, value: Any) -&gt; None:\n    \"\"\"Save a value to the storage\n\n    Args:\n        key (str): The key of the value\n        value (Any): The value to save\n\n    Raises:\n        KeyError: If the key already exists\n    \"\"\"\n    if self.exists(key):\n        raise KeyError(f\"Key '{key}' already exists\")\n    self._data[key] = value\n</code></pre>"},{"location":"components/validators/","title":"Validators","text":""},{"location":"components/validators/#validator","title":"Validator","text":"<p>A validator is a simple class that provides two methods: 1. validate Takes a schema and some data as input and provides a ValidationReport as output 2. is_valid Takes a schema and some data input and provides True if the data are valid and else False.</p>"},{"location":"components/validators/#api-docs","title":"API Docs","text":""},{"location":"components/validators/#validatorprotocol","title":"ValidatorProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for validators</p> <p>Validators implement at the very least the following methods:</p> <p>Methods:</p> Name Description <code>validate</code> <p>Validate a data item against a schema and return a validation report</p> <code>is_valid</code> <p>Validate a data item against a schema and return a boolean indicating if the data is valid</p> Source code in <code>sweet_validation/protocols/protocols.py</code> <pre><code>@runtime_checkable\nclass ValidatorProtocol(Protocol):\n    \"\"\"Protocol for validators\n\n    Validators implement at the very least the following methods:\n\n    Methods:\n        validate: Validate a data item against a schema and return a validation\n            report\n        is_valid: Validate a data item against a schema and return a boolean\n            indicating if the data is valid\n    \"\"\"\n\n    def validate(self, data: Any, schema: Any, **kwargs: Any) -&gt; Any: ...\n    def is_valid(self, data: Any, schema: Any, **kwargs: Any) -&gt; bool: ...\n</code></pre>"},{"location":"components/validators/#dummyvalidator","title":"DummyValidator","text":"<p>The DummyValidator is a validator that serves test cases. It allows to specify the response of the validator for a given schema and data. In that it ensures that the schema is loaded but does not perform any validation. But returns the expected response. It also serves as a blue print for the implementation of the Validator class.</p> Source code in <code>sweet_validation/validator/dummy.py</code> <pre><code>class DummyValidator:\n    \"\"\"The DummyValidator is a validator that serves test cases. It allows\n    to specify the response of the validator for a given schema and data. In that\n    it ensures that the schema is loaded but does not perform any validation.\n    But returns the expected response. It also serves as a blue print for the\n    implementation of the Validator class.\n    \"\"\"\n\n    response: bool\n\n    def __init__(self, response: bool = True) -&gt; None:\n        \"\"\"Initialize the DummyValidator\n\n        Args:\n            response (bool | None): Expected response of the validator\n        \"\"\"\n        self.response = response\n\n    def validate(\n        self, data: Any, schema: dict[str, Any], response: bool | None = None\n    ) -&gt; ValidationReport:\n        \"\"\"Validate the data against the schema\n\n        Args:\n            data (Any): Data to be validated\n            schema (dict[str, Any]): Schema to validate against\n            response (bool, optional): Expected response. Defaults to True.\n\n        Returns:\n            ValidationReport: Validation report\n        \"\"\"\n        response = response if response is not None else self.response\n        return ValidationReport(valid=response, errors={})\n\n    def is_valid(\n        self, data: Any, schema: dict[str, Any], response: bool | None = None\n    ) -&gt; bool:\n        \"\"\"Check if the data is valid against the schema\n\n        Args:\n            data (Any): Data to be validated\n            schema (dict[str, Any]): Schema to validate against\n            response (bool, optional): Expected response. Defaults to None which\n                uses the response provided during initialization.\n\n        Returns:\n            bool: True if valid else False\n        \"\"\"\n        return self.validate(data, schema, response=response).valid\n</code></pre>"},{"location":"components/validators/#sweet_validation.validator.DummyValidator.__init__","title":"<code>__init__(response=True)</code>","text":"<p>Initialize the DummyValidator</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>bool | None</code> <p>Expected response of the validator</p> <code>True</code> Source code in <code>sweet_validation/validator/dummy.py</code> <pre><code>def __init__(self, response: bool = True) -&gt; None:\n    \"\"\"Initialize the DummyValidator\n\n    Args:\n        response (bool | None): Expected response of the validator\n    \"\"\"\n    self.response = response\n</code></pre>"},{"location":"components/validators/#sweet_validation.validator.DummyValidator.is_valid","title":"<code>is_valid(data, schema, response=None)</code>","text":"<p>Check if the data is valid against the schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to be validated</p> required <code>schema</code> <code>dict[str, Any]</code> <p>Schema to validate against</p> required <code>response</code> <code>bool</code> <p>Expected response. Defaults to None which uses the response provided during initialization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid else False</p> Source code in <code>sweet_validation/validator/dummy.py</code> <pre><code>def is_valid(\n    self, data: Any, schema: dict[str, Any], response: bool | None = None\n) -&gt; bool:\n    \"\"\"Check if the data is valid against the schema\n\n    Args:\n        data (Any): Data to be validated\n        schema (dict[str, Any]): Schema to validate against\n        response (bool, optional): Expected response. Defaults to None which\n            uses the response provided during initialization.\n\n    Returns:\n        bool: True if valid else False\n    \"\"\"\n    return self.validate(data, schema, response=response).valid\n</code></pre>"},{"location":"components/validators/#sweet_validation.validator.DummyValidator.validate","title":"<code>validate(data, schema, response=None)</code>","text":"<p>Validate the data against the schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to be validated</p> required <code>schema</code> <code>dict[str, Any]</code> <p>Schema to validate against</p> required <code>response</code> <code>bool</code> <p>Expected response. Defaults to True.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ValidationReport</code> <code>ValidationReport</code> <p>Validation report</p> Source code in <code>sweet_validation/validator/dummy.py</code> <pre><code>def validate(\n    self, data: Any, schema: dict[str, Any], response: bool | None = None\n) -&gt; ValidationReport:\n    \"\"\"Validate the data against the schema\n\n    Args:\n        data (Any): Data to be validated\n        schema (dict[str, Any]): Schema to validate against\n        response (bool, optional): Expected response. Defaults to True.\n\n    Returns:\n        ValidationReport: Validation report\n    \"\"\"\n    response = response if response is not None else self.response\n    return ValidationReport(valid=response, errors={})\n</code></pre>"},{"location":"components/validators/#defaultvalidator","title":"DefaultValidator","text":"<p>The DefaultValidator class checks pandas dataframes against a frictionless schema.</p> Source code in <code>sweet_validation/validator/default.py</code> <pre><code>class DefaultValidator:\n    \"\"\"The DefaultValidator class checks pandas dataframes against a frictionless\n    schema.\n    \"\"\"\n\n    @staticmethod\n    def validate(data: pd.DataFrame, schema: dict[str, Any]) -&gt; ValidationReport:\n        \"\"\"Validate a pandas dataframe against a frictionless schema\n\n        Args:\n            data (pd.DataFrame): Data to validate\n\n        Raises:\n            ValidationError: If the data does not conform to the schema\n        \"\"\"\n        # convert schema to pandera schema\n        pa_schema = from_frictionless_schema(schema)\n        try:\n            pa_schema.validate(data, lazy=True)\n            return ValidationReport(valid=True, errors={})\n        except SchemaErrors as e:\n            return ValidationReport(valid=False, errors=e.message)\n\n    @staticmethod\n    def is_valid(data: pd.DataFrame, schema: dict[str, Any]) -&gt; bool:\n        \"\"\"Check if a pandas dataframe is valid against a frictionless schema\n\n        Args:\n            data (pd.DataFrame): Data to validate\n\n        Returns:\n            bool: True if the data is valid, False otherwise\n        \"\"\"\n        return DefaultValidator.validate(data, schema).valid\n</code></pre>"},{"location":"components/validators/#sweet_validation.validator.DefaultValidator.is_valid","title":"<code>is_valid(data, schema)</code>  <code>staticmethod</code>","text":"<p>Check if a pandas dataframe is valid against a frictionless schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>Data to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data is valid, False otherwise</p> Source code in <code>sweet_validation/validator/default.py</code> <pre><code>@staticmethod\ndef is_valid(data: pd.DataFrame, schema: dict[str, Any]) -&gt; bool:\n    \"\"\"Check if a pandas dataframe is valid against a frictionless schema\n\n    Args:\n        data (pd.DataFrame): Data to validate\n\n    Returns:\n        bool: True if the data is valid, False otherwise\n    \"\"\"\n    return DefaultValidator.validate(data, schema).valid\n</code></pre>"},{"location":"components/validators/#sweet_validation.validator.DefaultValidator.validate","title":"<code>validate(data, schema)</code>  <code>staticmethod</code>","text":"<p>Validate a pandas dataframe against a frictionless schema</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>Data to validate</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the data does not conform to the schema</p> Source code in <code>sweet_validation/validator/default.py</code> <pre><code>@staticmethod\ndef validate(data: pd.DataFrame, schema: dict[str, Any]) -&gt; ValidationReport:\n    \"\"\"Validate a pandas dataframe against a frictionless schema\n\n    Args:\n        data (pd.DataFrame): Data to validate\n\n    Raises:\n        ValidationError: If the data does not conform to the schema\n    \"\"\"\n    # convert schema to pandera schema\n    pa_schema = from_frictionless_schema(schema)\n    try:\n        pa_schema.validate(data, lazy=True)\n        return ValidationReport(valid=True, errors={})\n    except SchemaErrors as e:\n        return ValidationReport(valid=False, errors=e.message)\n</code></pre>"},{"location":"components/validators/#validationreport","title":"ValidationReport","text":"<p>Validation report class.</p> <p>It provides two main properties:</p> <ul> <li><code>valid</code> - a boolean flag indicating whether the validation was successful</li> <li><code>errors</code> - a list of validation errors</li> </ul> Source code in <code>sweet_validation/validator/validation_report.py</code> <pre><code>class ValidationReport:\n    \"\"\"Validation report class.\n\n    It provides two main properties:\n\n    - `valid` - a boolean flag indicating whether the validation was successful\n    - `errors` - a list of validation errors\n    \"\"\"\n\n    valid: bool\n    errors: dict[Any, Any]\n\n    def __init__(self, valid: bool, errors: dict[Any, Any]) -&gt; None:\n        self.valid = valid\n        self.errors = errors\n\n    def __eq__(self, value: object) -&gt; bool:\n        if not isinstance(value, ValidationReport):\n            return False\n        if self.valid == value.valid and self.errors == value.errors:\n            return True\n        return False\n</code></pre>"},{"location":"frictionless/frictionless/","title":"Frictionless Data","text":""},{"location":"frictionless/frictionless/#overview","title":"Overview","text":"<p>We use the Frictionless Data standard to describe data. In short the frictionless standard relies on to four main components:</p> <ol> <li>Table schema provides a section to describe a table, i.e., a meta-data section     and describes the table schema in terms of fields.</li> <li>Table dialect provides the possibility to describe the physical properties     of a table, i.e, how data are stored in a file.</li> <li>Data resource is the combination of a datafile and the respective descriptions     given in the form of table schemas and dialects.</li> <li>Data package allows to bundle several data resources.</li> </ol> <p>Our package relies on table schemas to describe data and we therefore explain their concept in greater detail.</p>"},{"location":"frictionless/frictionless/#table-schema","title":"Table Schema","text":"<p>A frictionless table schema is a json-schema specification to standardize the exchange of data. For all details take a look at the specification of the table schema. Our approach uses yaml files to describe data. Consider the following example of such a yaml:</p> <pre><code>name: generation\ntitle: Electricity generation\ndescription: &gt;\n    Electricity generation created by our awesome very unique electricity model\n    that is technically and economically very advanced. The table provides\n    annual generation by technology and year.\ncreated_by: User\ncreated_at: 2025-01-31\nfields:\n  - name: technology\n    type: string\n    constraint:\n        required: true\n        enum: [gas, coal, wind, solar]\n  - name: year\n    type: integer\n    constraint:\n        required: true\n        minimum: 2000\n        maximum: 2100\n  - name: value\n    type: number\n    constrain:\n        required: true\n</code></pre> <p>The table schema comes in two parts. The first part are the meta-data that describe the data and provides additional information, e.g., operational meta-data who created the data and at which date. The description of relational constrains including primary and foreign keys is also possible. It is possible to add any field you want to the meta-data section.</p> <p>The fields part describes the columns of the data. fields are by default the only part that is mandatory. A field has to have a name and should have at least a type, i.e, whether you are storing strings, numbers, integer, ... (see description of all possible types). Fields can be narrowed down using constraints:</p> <ul> <li>required: Whether the field must be given</li> <li>unique: Whether values in the field must be unique</li> <li>minLength/maxLength: Allows to set the minimal and maximum value for collections (arrays, lists, strings)</li> <li>maximum/minimum: Maximum/minimum for numerical values</li> <li>pattern: Restrict strings by regular expressions</li> <li>enum: Define a list of valid values for a string</li> </ul>"}]}